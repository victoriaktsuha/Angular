<div class="container">
  <div>
    <br />
    <h1>
      <b>{{ title }}</b>
    </h1>
    <!-- <img
      width="300"
      alt="Angular Logo"
      src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNTAgMjUwIj4KICAgIDxwYXRoIGZpbGw9IiNERDAwMzEiIGQ9Ik0xMjUgMzBMMzEuOSA2My4ybDE0LjIgMTIzLjFMMTI1IDIzMGw3OC45LTQzLjcgMTQuMi0xMjMuMXoiIC8+CiAgICA8cGF0aCBmaWxsPSIjQzMwMDJGIiBkPSJNMTI1IDMwdjIyLjItLjFWMjMwbDc4LjktNDMuNyAxNC4yLTEyMy4xTDEyNSAzMHoiIC8+CiAgICA8cGF0aCAgZmlsbD0iI0ZGRkZGRiIgZD0iTTEyNSA1Mi4xTDY2LjggMTgyLjZoMjEuN2wxMS43LTI5LjJoNDkuNGwxMS43IDI5LjJIMTgzTDEyNSA1Mi4xem0xNyA4My4zaC0zNGwxNy00MC45IDE3IDQwLjl6IiAvPgogIDwvc3ZnPg==" /> -->
  </div>
  <br />
  <p>
    This content was created with the intention of exploring my own learning
    journey in order to reinforce it and is based on the
    <a href="https://www.udemy.com/">Udemy</a> course
    <a
      href="https://ssgacademy.udemy.com/course/the-complete-guide-to-angular-2">
      Angular - The Complete Guide (2023 Edition)
    </a>
    well-instructed by
    <a href="https://www.udemy.com/user/maximilian-schwarzmuller/"
      >Maximilian Schwarzmüller</a
    >
  </p>
  <p>
    <b>
      I emphasize that these texts are my own authorship and do not represent
      the opinion and responsibility of Udemy or the instructor in any way. Any
      conflicts or problems with the content, or even feedback, will be welcome
      in this
      <a
        href="mailto:victoriaktsuha@gmail.com?subject=[Contact] My Angular Journey&bcc=victoriaktsuha@outlook.com&body=Olá! O motivo do meu contato é"
        >email</a
      ></b
    >
  </p>
  <br />
  <h5>Here are some Angular official links to help you start:</h5>
  <ul>
    <li>
      <a target="_blank" rel="noopener" href="https://angular.io/tutorial"
        >Tour of Heroes</a
      >
    </li>
    <li>
      <a target="_blank" rel="noopener" href="https://angular.io/cli"
        >CLI Documentation</a
      >
    </li>
    <li>
      <a target="_blank" rel="noopener" href="https://blog.angular.io/"
        >Angular blog</a
      >
    </li>
  </ul>
  <hr />
  <br />
  <h2 id="1"><b>#1 Getting Started</b></h2>
  <br /><br />
  <h3><b>Course Structure</b></h3>
  <br />
  <ul>
    <li>
      <b><a href="#1">1. Getting Started</a></b>
    </li>
    <li>
      <b><a href="#2">2. The Basics</a></b>
    </li>
    <li>
      <b><a href="#3">3. Components & Databinding</a></b>
    </li>
    <li>
      <b><a href="#4">4. Directives</a></b>
    </li>
    <li>
      <b><a href="#5">5. Services & Dependency Injection</a></b>
    </li>
    <li>
      <b><a href="#6">6. Rounting</a></b>
    </li>
    <li>
      <b><a href="#7">7. Observables</a></b>
    </li>
    <li>
      <b><a href="#8">8. Forms</a></b>
    </li>
    <li>
      <b><a href="#9">9. PIpes</a></b>
    </li>
    <li>
      <b><a href="#10">10. HTTP</a></b>
    </li>
    <li>
      <b><a href="#11">11. Authentication</a></b>
    </li>
    <li>
      <b><a href="#12">12. Optimizations & NgModules</a></b>
    </li>
    <li>
      <b><a href="#13">13. Deployment</a></b>
    </li>
    <li>
      <b><a href="#14">14. Animations & Testing</a></b>
    </li>
  </ul>
  <br /><br />
  <h3><b>Whats is Angular?</b></h3>
  <br />
  <p>
    Angular is Javascript Framework which allows you to create reactive
    Single-Page-Applications (SPAs)<br /><br />
    A SPA is single html file where you can navigate between different pages,
    but never actually leave that html, with the changes being rendered in the
    browser. It gives user a very reactive experience, creating a web
    application which looks and feel like mobile apps, very fast and instant.
    The data from server is loaded in the backgorund to user not need to leave
    the page and wait it to load again events.
    <br /><br />
    It's possible because JS changes the DOM during the runtime, thats why we
    don't see a load page, because where changing just the current page.
  </p>
  <br /><br />
  <h3><b>CLI Deep Dive & Troubleshooting</b></h3>
  <br />
  <p>
    If you want to dive deeper into the CLI and learn more about its usage, have
    a look at its official documentation:
    <a href="https://github.com/angular/angular-cli/wiki"
      >https://github.com/angular/angular-cli/wiki</a
    >
    <br /><br />
    <b
      >You encountered issues during the installation of the CLI or setup of a
      new Angular project?</b
    >
    <br /><br />
    A lot of problems are solved by making sure you're using the latest version
    of NodeJS, npm and the CLI itself.
    <br /><br />
    <b>Updating NodeJS:</b><br /><br />

    Go to <a href="nodejs.org">nodejs.org</a> and download the latest version -
    uninstall (all) installed versions on your machine first. <br /><br />
    <b>Updating npm:</b>
    <br /><br />
    Run <span class="code">[sudo] npm install -g npm</span> (<i>sudo</i> is only
    required on Mac/ Linux) <br /><br />
    <b>Updating the CLI</b>
    <br /><br />
    <span class="code">[sudo] npm uninstall -g angular-cli @angular/cli</span
    ><br /><br />
    <span class="code">npm cache verify</span><br /><br />
    <span class="code">[sudo] npm install -g @angular/cli</span><br /><br />

    <b>Here are some common issues & solutions:</b> <br /><br />
    <b>1. Creation of a new project takes forever (longer than 3 minutes)</b
    ><br />That happens on Windows from time to time => Try running the command
    line as administrator<br /><br />
    <b>2. You get an EADDR error (Address already in use)</b><br />
    You might already have another ng serve process running - make sure to quit
    that or use <span class="code">ng serve --port ANOTHERPORT</span> to serve
    your project on a new port<br /><br />
    <b>3. My changes are not reflected in the browser (App is not compiling)</b
    ><br />
    Check if the window running <span class="code">ng serve</span> displays an
    error. If that's not the case, make sure you're using the latest CLI version
    and try restarting your CLI
  </p>
  <br /><br />
  <h3><b>Project Setup and First App</b></h3>
  <br />
  <p>
    For that, we'll use CLI, the official Angular command line interface. It's
    the recommended way to create Angular projects because they're more complex
    regarding their build workflow<br /><br />
    <b>1. Installing latest version of <a href="nodejs.org">Node.js</a></b
    ><br /><br />
    <b>2. Installing Angular</b><br /><br />
    Run <span class="code">npm install -g @angular/cli@latest</span> (@latest is
    optional)<br /><br />
    <b>3. Create you Angular project</b><br /><br />
    Navigate to the folder that you want to create the project (cd path/...) and
    run <span class="code">ng new project-name</span><br />CLI will give some
    choices to do to config the project the way you want.<br /><br />
    When it finished, navigate to your project folder and run
    <span class="code">ng serve</span><br /><br />
    The server runs at the <a href="localhost:4200">localhost:4200</a> by
    default <br /><br />
    <b>4. Installing and Config Bootstrap</b><br /><br />
    In your terminal/cmd, run
    <span class="code">npm install --save bootstrap@latest </span><br />(here
    we're installing it locally, without the <i>-g</i>)<br /><br />
    After finished, open your <i>angular.json</i> file and in the
    <i>styles:</i> key, add the bootstrap file path localed in the
    <i>node_modules</i> folder:<br /><br />
    <i
      >"styles": [<br />
      &nbsp;&nbsp;&nbsp;&nbsp;"src/styles.scss",<br />
      &nbsp;&nbsp;&nbsp;&nbsp;"src/stylesheet.css",<br />
      &nbsp;&nbsp;&nbsp;&nbsp;"node_modules/bootstrap/dist/css/bootstrap.min.css",<br />
      &nbsp;&nbsp;&nbsp;&nbsp;"node_modules/bootstrap/scss/bootstrap.scss"<br />
      ],</i
    ><br /><br />
    You can add any stylesheet file you need.
  </p>
  <br /><br />
  <h3><b>What is Typescript ?</b></h3>
  <br />
  <p>
    It's a superset of JS, with more feature than Vanilla JS (e.g. Types,
    Classes, Interfaces,...). The code errors can be verify while you write, and
    not just when you run it.<br />
    But TS is not execute in the browser, so it's compiled to JS in the end by
    the the Angular project manager CLI
  </p>
  <br /><br />
  <h3><b>About the Course Code / Code Snapshots</b></h3>
  <br />
  <p>
    <b>Do you get some strange error? Are you stuck?</b><br /><br />
    <b>One important note:</b> All the course code will only work if you are
    <b>NOT using "strict mode"</b> see the "First App" lecture in this module.
    Strict mode forces you to write more verbose code in some places (especially
    when it comes to class properties). If you enabled it by accident, you can
    also disable it by setting <span class="code">strict: false</span> in your
    <span class="code">tsconfig.json</span> file.<br /><br />Due to dependency
    version mismatches, running the attachments might fail though - in that
    case, you can try the following:<br /><br />
    1&rpar; Create a new project via
    <span class="code">ng new my-project --strict false</span> (the
    <span class="code">--strict false</span> part is important!)<br />
    2&rpar; Copy the content of the ZIP attachment
    <span class="code">src/app</span> folder into the newly created project
    <span class="code">src/app</span> folder. <br />3&rpar; Run your project
    (<span class="code">my-project</span>) via
    <span class="code">ng serve</span>
    If you're getting errors when running <span class="code">npm install</span>,
    you can often solve them by running
    <span class="code">npm install --legacy-peer-deps</span> instead of
    <span class="code">npm install</span>
  </p>
  <br /><br /><br />
  <h1 id="2"><b>#2 The Basics</b></h1>
  <br />
  <br /><br />
  <h3><b>How an Angular App gets Loaded and Started</b></h3>
  <br />
  <p>
    The 'single-page' serve by the server is the <b><i>index.html</i></b> and
    inside it, we have the <b><i>'app-root'</i></b> selector, which was defined
    in the <b><i>app.component.ts</i></b
    >. So the content that we see first when the server is running at
    <a href="localhost:4200">localhost:4200</a>, is the content inside
    <b><i>app.component.html</i></b
    ><br /><br />
    The <b><i>'app.component'</i></b> is the component that CLI created for us
    and the one that will tie everything together at the end, the
    <b>root component</b>. And when <span class="code">'ng serve'</span> is run,
    it will inject the right package bundles and scripts to build the app, that
    we don't see in the index file, but can be seeing in a quick web page
    inspection.<br /><br />
    The first code that is requested when we start the app (<span class="code"
      >ng-serve</span
    >) is the <b><i>main.ts</i></b
    >, where we import <b><i>app.module.ts</i></b
    >, and we indicate it to be started with the server in the line
    <span class="code">platformBrowserDynamic().bootstrapModule(AppModule)</span
    >.<br /><br />
    This method will reach the <b><i>'app.module.ts'</i></b
    >, where we have a bootstrap array, which receive the component that should
    be consider in the app start moment by this bootstrap method.<br />
    In this array, we indicate the <b><i>AppComponent</i></b
    >, that will have its content 'read' by bootstrap method when the app will
    be started and that holds the selector <b><i>'app-root'</i></b
    >, which is included in the <b><i>index.html</i></b> (the
    <i>'single-page'</i>), closing the 'cycle'.<br /><br />
    <img
      class="img-responsive d-flex m-auto"
      src="../assets/images/graf-angularstar.svg" />
  </p>
  <br /><br />
  <h3><b>Components are important!</b></h3>
  <br />
  <p>
    The Angular application is basically composed by a bunch of other components
    inside the 'root' component. The benefits of this kind of structure are:
  </p>
  <ul>
    <li>Reusability</li>
    <li>Personalization</li>
    <li>Easy to update</li>
  </ul>
  <br /><br />
  <h3><b>Creating a new Component</b></h3>
  <br />
  <p>Before create a new component, some rules:</p>
  <ul>
    <li>
      Any other components will <b>not be added</b> to index.html. There must be
      remain just the <i>'app-root'</i>
    </li>
    <li>
      As it is with index.html, any other component <b>won't be added</b> to
      <b>'bootstrap:[ ]'</b> in the 'app.module.ts', there must remain just the
      'AppComponent'
    </li>
    <li>
      <b>New components</b> create inside the App Component folder, will be
      added to <b>'declarations:[ ]'</b> in the 'app.module.ts'; It goes for for
      any other new module with new components
    </li>
  </ul>
  <br />
  <p class="obs">
    *For this lecture, the 'server' component was created manually
  </p>
  <p>1. In your IDE, create 'server' folder inside the 'app' folder</p>
  <p>
    2. Inside 'server' folder, create <i>'server.component.html'</i> and
    <i>'server.component.ts'</i>
  </p>
  <p>
    3. Then in <i>'server.component.ts'</i>, we will create the configuration
    for this component:
  </p>
  <span class="code" style="border: none">
    import &lbrace; Component &rbrace; from '@angular/core'; <br /><br />
    @Component(&lbrace;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;selector: 'app-server',<br />
    &nbsp;&nbsp;&nbsp;&nbsp;templateUrl: './server.component.html'<br />
    &nbsp;&nbsp;&nbsp;&nbsp;styleUrls: ['./server.component.scss'],
    <br />&rbrace;)<br /><br />
    export class ServerComponent &lbrace;&rbrace; </span
  ><br /><br />
  4. Add the component to the <b><i>app.module.ts</i></b
  >:<br /><br />
  <span class="code" style="border: none">
    declarations: [<br />
    &nbsp;&nbsp;&nbsp;&nbsp;AppComponent, ServerComponent <br />]
  </span>
  <br /><br /><br /><br />
  <h3><b>Understanding the Role of AppModule and Component Declaration</b></h3>
  <br />
  <p>The 'server' component selector is now added below:</p>
  <div class="card">
    <div class="card-header"><b>Result View</b></div>
    <div class="card-body"><app-servers></app-servers></div>
  </div>
  <br /><br /><br />
  <h3><b>Creating Components with the CLI & Nesting Components</b></h3>
  <br />
  <p>
    Open a new terminal/CLI (to not close where server is running), and run:
  </p>
  <span class="code">ng generate component name-component --skip-tests</span
  ><br />
  <span class="obs"
    >*The component will be automatically created inside the app folder</span
  ><br /><br />
  <p>
    The <b><i>'app-server'</i></b> was added inside the
    <b><i>'app-servers'</i></b
    >, allows us to use them separatelly or inside other components as below:
  </p>
  <div class="card">
    <div class="card-header"><b>Result View</b></div>
    <div class="card-body"><app-servers></app-servers></div>
  </div>
  <!-- <div app-servers></div> -->
  <!-- <div class="app-servers"></div> -->
  <br /><br /><br />
  <h3><b>Working with Components templates</b></h3>
  <br />
  <p>
    In this case, the template is define in the Typescript file, as we're doing
    in the <b><i>'server.component'</i></b
    >:
  </p>
  <br />
  <span class="code" style="border: none">
    import &lbrace; Component &rbrace; from '@angular/core';
    <br /><br />
    @Component(&rbrace;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;selector: 'app-servers',<br />
    &nbsp;&nbsp;&nbsp;&nbsp;template:
    '&lt;app-server&gt;&lt;/app-server&gt;&lt;app-server&gt;&lt;/app-server&gt;',<br />
    &nbsp;&nbsp;&nbsp;&nbsp;styleUrls: ['./servers.component.sass'],<br />
    &rbrace;)<br /><br />
    export class ServersComponent &lbrace;&rbrace; </span
  ><br /><br />
  Resulting in this (the same as before):<br /><br />
  <div class="card">
    <div class="card-header"><b>Result View</b></div>
    <div class="card-body"><app-servers></app-servers></div>
  </div>
  <!-- <div app-servers></div> -->
  <!-- <div class="app-servers"></div> -->
  <br /><br />
  <p>
    To use multiple lines at the <b><i>'template'</i></b
    >, use <b>` `</b> instead <b>' '</b>
  </p>
  <span class="code" style="border: none">
    import &lbrace; Component &rbrace; from '@angular/core';
    <br /><br />
    @Component(&rbrace;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;selector: 'app-servers',<br />
    &nbsp;&nbsp;&nbsp;&nbsp;template: `&lt;app-server&gt;&lt;/app-server&gt;<br />&lt;app-server&gt;&lt;/app-server&gt;`,<br />
    &nbsp;&nbsp;&nbsp;&nbsp;styleUrls: ['./servers.component.sass'],<br />
    &rbrace;)<br /><br />
    export class ServersComponent &lbrace;&rbrace; </span
  ><br /><br />
  <p>
    Choose between inline template (inside Typescript) as above or external file
    with <b><i>templateUrl: "./app.component.html"</i></b>
  </p>
  <br /><br />
  <h3><b>Working with Components styles</b></h3>
  <br />
  <p>
    You can the own component <i>'.css'</i> file to style the component
    differently or use the own component Typescript file to style directly in
    the key 'style':
  </p>
  <br />
  <span class="code" style="border: none">
    @Component(&lbrace;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;selector: "app-root",<br />
    &nbsp;&nbsp;&nbsp;&nbsp;templateUrl: "./app.component.html", <br />
    &nbsp;&nbsp;&nbsp;&nbsp;styles: [`<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h3
    &lbrace;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color:
    dodgerblue;
    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rbrace;
    <br />&nbsp;&nbsp;&nbsp;&nbsp;`] <br />&rbrace;)</span
  ><br /><br />
  <p>
    Choose between inline style (inside Typescript) as above or external file
    with <b><i>styleUrls: ['./app.component.scss']</i></b>
  </p>
  <br /><br />
  <h3><b>Fully Understanding the Component Selector</b></h3>
  <br />
  <p>
    Since we define selector similar to CSS stylesheet, just typing the name
    like <b><i>'app-server'</i></b
    >, we have another way to use selector:
  </p>
  <br />
  <h5><b>Selector by attribute</b></h5>
  <br />
  <span class="code">selector: "[app-servers]"</span>
  <br /><br />
  To display it, in the HTML this must added like this:<br /><br />
  <span class="code"> &lt;div app-servers&gt;&lt;/div&gt; </span><br /><br />
  <br />
  <h5><b>Selector by class</b></h5>
  <br />
  <span class="code">selector: ".app-servers"</span>
  <br /><br />
  To display it, in the HTML this must added like this:<br /><br />
  <span class="code"> &lt;div class="app-servers"&gt;&lt;/div&gt; </span
  ><br /><br />
  <ul>
    <li>
      Must be a unique selector, preferencially following the standard
      <b><i>'app-nameapp'</i></b>
    </li>
    <li>
      The recommended way to declare selector is still
      <span class="code">selector: 'app-servers'</span>
    </li>
  </ul>
  <br /><br />
  <h3><b>Assignment 1: Practicing Components</b></h3>
  <p>
    1. Create two new Components (manually or with CLI): WarningAlert and
    SuccessAlert
  </p>
  <p>2. Output them beneath each other in the AppComponent</p>
  <p>3. Output a warning or success message in the Components</p>
  <p>4. Style the Components appropriately (maybe some red/green text?)</p>
  <p>Use extrernal or internal templates and styles</p>
  <p>
    Feel free to create more components, nest into each other or play around
    with different types of selections
  </p>
  <br />
  <div class="card">
    <div class="card-header"><b>Result View</b></div>
    <div class="card-body">
      <app-success></app-success><br />
      <app-warning></app-warning>
    </div>
  </div>
  <br /><br />
  <h3><b>What is Databinding</b></h3>
  <br />
  <p>
    It's the communication between your Typescript code (business logic) and
    your template (HTML).<br /><br />
    We can <b>Output Data</b> from the TS file to HTML template, using:
  </p>
  <ul>
    <li>
      <b>String Interpolation</b> (<span class="code"
        >&lbrace; &lbrace; data &rbrace; &rbrace;</span
      >)
    </li>
    <li>
      <b>Property Binding</b> (<span class="code"
        >&lbrack;property&rbrack;="data"</span
      >)
    </li>
  </ul>
  <br />
  <p>
    We can <b>React to (User) Events</b> from HTML template to TS file, using:
  </p>
  <ul>
    <li>
      <b>Event Binding</b> (<span class="code"
        >&lpar;event&rpar;="expression"</span
      >)
    </li>
  </ul>
  <p>
    Combining of both: <b>Two-Way-Binding</b> (<span class="code"
      >&lbrack;&lpar;ngModel&rpar;&rbrack;="data"</span
    >)
  </p>
  <br /><br />
  <h3><b>String Interpolation</b></h3>
  <br />
  <p>
    Supposing we want to output to template a server ID and status, two dynamic
    informations.<br /><br />Using the <b><i>'server.component'</i></b
    >, in the Typescript file, we add the variables:
  </p>
  <span class="code" style="border: none">
    export class ServerComponent &lbrace;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;serverId: number = 10;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;serverStatus: string = 'offline';<br />
    &rbrace;<br /> </span
  ><br />
  <p class="obs">
    Any expression that can be solved/converted to a string in the end, that's
    the condition for a string interpolation
  </p>
  <br />
  <p>
    In the <b><i>'component.html'</i></b> file, you can add:<br /><br />
    <span class="code"
      >&lt;p&gt; &lbrace; &lbrace; 'Server' &rbrace; &rbrace; with ID &lbrace;
      &lbrace; serverId &rbrace; &rbrace; is &lbrace; &lbrace; serverStatus
      &rbrace; &rbrace; &lt;/p&gt;</span
    >
  </p>
  <br />
  <div class="card">
    <div class="card-header"><b>Result View</b></div>
    <div class="card-body"><app-server></app-server></div>
  </div>
  <br />
  <p>The restrictions is that you <b>can't</b> write:</p>
  <ul>
    <li>multiple lines expression</li>
    <li>block expression</li>
    <li>'if' or 'for' structure</li>
  </ul>
  <br />
  <p>
    But you can write a <b>ternary expression:</b><br /><br />
    <span class="code"
      >(age >= 18) ? console.log("Can Vote") : console.log("Cannot Vote");</span
    >
  </p>
  <br />
  <p>And you can also use a <b>method:</b></p>
  <p>In the Typescript file:</p>
  <span class="code" style="border: none">
    export class ServerComponent &lbrace;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;serverId: number = 10;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;serverStatus: string = 'offline';<br /><br />
    getServerStatus&lpar;&rpar;&lbrace;<br />&nbsp;&nbsp;&nbsp;&nbsp;return
    this.serverStatus; <br />&rbrace; </span
  ><br /><br />
  <p>In the HTML:</p>
  <span class="code"
    >&lt;p&gt; Server with ID &lbrace; &lbrace; serverId &rbrace; &rbrace; is
    &lbrace; &lbrace; getServerStatus() &rbrace; &rbrace; &lt;/p&gt;</span
  ><br /><br />
  <div class="card">
    <div class="card-header"><b>Result View</b></div>
    <div class="card-body"><app-server></app-server></div>
  </div>
  <br /><br />
  <h3><b>Property Binding</b></h3>
  <br />
  <p>
    Supposing we want to allow user <b>add</b> a new server - button must be
    enable to user after certain time:<br /><br />We add a button 'Add server'
    at the template and the code in the Typescript file:<br /><br />
    <span class="code" style="border: none">
      export class ServersComponent &lbrace;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;allowNewServer = false;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;constructor() &lbrace;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(()
      => &lbrace;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.allowNewServer
      = true;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rbrace;,2000);<br />&nbsp;&nbsp;&nbsp;&nbsp;&rbrace;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;ngOnInit(): void &lbrace;&rbrace;<br />
      &rbrace;
    </span>
  </p>
  <br />
  <p>
    In HTML, we're going to <b>bind</b> the <i>disabled</i> property to our
    expression written before, that with the <i>setTimeout()</i> method, after
    the <i>'2000'</i> miliseconds defined, will set <i>'true'</i> to the
    'allowNewServer' property, enabling the button
  </p>
  <br />
  <span class="code">
    &lt;button class="btn btn-primary" &lbrack;disabled]="!allowNewServer">Add
    server&lt;/button> </span
  ><br /><br />
  <p class="obs">
    &lbrack;disabled]="!allowNewServer" is read like: 'disabled' property will
    only be true if 'allowNewServer' is false
  </p>
  <br /><br />
  <div class="card">
    <div class="card-header"><b>Result View</b></div>
    <div class="card-body"><app-servers></app-servers></div>
  </div>
  <br /><br />
  <h3><b>Property Binding vs String Interpolation</b></h3>
  <br />
  <p>
    If in the case we also want to output the value of the new server, we could
    use <b>string interpolation</b>:
  </p>
  <span class="code"
    >&lt;p>&lbrace; &lbrace; allowNewServer &rbrace; &rbrace;&lt;/p></span
  ><br /><span class="obs">Boolean values can be translated to string</span
  ><br /><br />
  <div class="card">
    <div class="card-header"><b>Result View</b></div>
    <div class="card-body"><app-servers></app-servers></div>
  </div>
  <br /><br />
  <p>
    But this is case where we can also use
    <b>property binding instead string interpolation</b> to get the same result:
  </p>
  <span class="code">&lt;p &lbrack;innerText]="allowNewServer">&lt;/p></span>
  <br /><br /><br />
  <p><b>Which one should I use?</b></p>
  <p>
    If you want to output just <b>text</b> basically, use
    <b>string interpolation</b>;<br /><br />If you want to
    <b>change some property</b>, be of a
    <b>HTML file or a directive component</b>, use <b>property binding</b>
  </p>
  <br />
  <p><b>DON'T MIX</b> property binding and string interpolation:</p>
  <span class="code"
    >&lt;p &lbrack;innerText]="&lbrace; &lbrace;allowNewServer &rbrace;
    &rbrace;">&lt;/p></span
  >
  <br /><br /><br /><br />
  <h3><b>Event Binding</b></h3>
  <br />
  <p>
    When user clicks on the button 'Add Server', we want to react at this event.
    So, in the <b><i>component.ts</i></b
    >, we create the property:
  </p>
  <p>
    <span class="code">serverCreationStatus = 'No server was created!';</span>
  </p>
  <p>And the method:</p>
  <p>
    <span class="code" style="border: none"
      >onCreateServer() &lbrace;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;this.serverCreationStatus = 'Server was created!';
      <br />&rbrace;</span
    >
  </p>
  <p class="obs">
    Beggining the method name with 'on..' make more easy to know that is a event
    binding, some reaction to user action
  </p>
  <p>
    In the HTML (of the same method component !), we <b>comment</b> the
    <span class="code"
      >&lt;p &lbrack;innerText]="&lbrace; &lbrace;allowNewServer &rbrace;
      &rbrace;">&lt;/p></span
    >
    and add:
  </p>
  <p>
    <span class="code"
      >&lt;p>&lbrace; &lbrace; serverCreationStatus &rbrace;
      &rbrace;&lt;/p></span
    >
  </p>
  <p>To the button 'Add Server', we add:</p>
  <p><span class="code">&lpar;click&rpar;="onCreateServer()"</span></p>
  <p>So when clicked, the string changes to 'Server was created'</p>
  <p class="obs">
    *Property Binding uses '[ ]', while Event Binding uses '( )'
  </p>
  <div class="card">
    <div class="card-header"><b>Result View</b></div>
    <div class="card-body"><app-servers></app-servers></div>
  </div>
  <br /><br /><br />
  <h3><b>Bindable Properties and Events</b></h3>
  <br />
  <p>
    How do you know to which Properties or Events of HTML Elements you may bind?
    You can basically bind to all Properties and Events - a good idea is to
    <span class="code">console.log()</span> the element you're interested in to
    see which properties and events it offers.
  </p>
  <p>
    <b>Important:</b> For events, you don't bind to onclick but only to click
    (=> (click)).
  </p>
  <p>
    The MDN (Mozilla Developer Network) offers nice lists of all properties and
    events of the element you're interested in. Googling for
    <span class="code">YOUR_ELEMENT properties</span> or
    <span class="code">YOUR_ELEMENT events</span> should yield nice results.
  </p>
  <br /><br />
  <h3><b>Passing and Using Data with Event Binding</b></h3>
  <br />
  <p>
    In the <i>'component.html'</i>, the user now will be able to add the server
    name with the <i><b>(input)</b></i> event:<br />
    <span class="code"
      >&lt;input type="text" class="form-control"
      &lpar;input&rpar;="onUpdateServerName()" /><br /></span
    ><br />
    The (input) is a event that is triggered by the keystroke and can give us
    data about the event.
    <br /><br />
    And we also need to output what user entered as server name, the value of
    the input field. So we add <span class="code">$event</span> at the event
    binding in HTML file:<br />
    <span class="code"
      >&lt;input type="text" class="form-control"
      &lpar;input&rpar;="onUpdateServerName($event)" /></span
    ><br />
    Only inside the "methodName($event)", the
    <b><i>$event </i></b>will capture the data emitted with this event
    <br /><br />
    In the <i>'component.ts'</i> we're going to add our method that is binded in
    the DOM event <i>(input)</i>:<br /><br />
    <span class="code no-border"
      >onUpdateServerName(event: Event) &lbrace;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;this.serverName =
      (&lt;HTMLInputElement>event.target).value;<br />&rbrace;</span
    ><br />
    <span class="obs"
      >(&lt;HTMLInputElement>event.target) is needed to inform TS that we know
      that the type of the HTML element of this event will be a HTML input
      element</span
    ><br /><br />
    Now in the HTML we will output the server name:<br /><br />
    <span class="code"
      >&lt;p>&lbrace; &lbrace;serverName&rbrace; &rbrace;&lt;/p></span
    ><br /><br />
  </p>
  <div class="card">
    <div class="card-header"><b>Result View</b></div>
    <div class="card-body"><app-servers></app-servers></div>
  </div>
  <br /><br />
  <h3><b>Important: FormsModule is Required for Two-Way-Binding!</b></h3>
  <br />
  <p>
    Important: For Two-Way-Binding (covered in the next lecture) to work, you
    need to enable the <span class="code">ngModel</span> directive. This is done
    by adding the <span class="code">FormsModule</span> to the
    <span class="code">imports[]</span> array in the AppModule.<br /><br />

    You then also need to add the import from
    <span class="code">@angular/forms</span> in the app.module.ts file:<br /><br />

    <span class="code"
      >import &lbrace; FormsModule &rbrace; from '@angular/forms';</span
    >
  </p>
  <br /><br />
  <h3><b>Two-Way DataBinding</b></h3>
  <br />
  <p>
    With Two-Way-Binding, we combine property and event binding. We use
    <b><i>[( )]</i></b> and a directive, in this case, <b><i>ngModel</i></b
    ><br /><br />
    <b>Important:</b> To be able to use <b><i>ngModel</i></b
    >, the <b><i>FormsModule</i></b> (from
    <span class="code">@angular/forms</span>) needs to be added to your
    <span class="code">imports[]</span> array in the <b>AppModule</b> (should ne
    there by default in a CLI project)!<br /><br />
    Let's replace the previously <i>event binding</i> code to the
    <i>two-way binding</i> structure:<br /><br />
    <span class="code"
      >&lt;input type="text" class="form-control"
      &lbrack;(ngModel)]="serverName" /></span
    ><br /><br />
    This will trigger in the input event and update the value of server name in
    the component automatically. On the other hand, since is two-way binding, it
    will update the value of the input element if we change server name
    somewhere else
  </p>
  <div class="card">
    <div class="card-header"><b>Result View</b></div>
    <div class="card-body"><app-servers></app-servers></div>
  </div>
  <br /><br />
  <h3><b>Assignment 2: Practicing Databinding</b></h3>
  <br />
  <p>
    1. Add a input field which updates a property ('username') via
    Two-Way-Binding
  </p>
  <p>
    2. Output the username property via String Interpolation (in a paragraph
    below the input)
  </p>
  <p>
    3. Add a button which may only be clicked if the username is NOT an empty
    string
  </p>
  <p>
    4. Upon clicking the button, the username should be reset to an empty string
  </p>
  <div class="card">
    <div class="card-header"><b>Result View</b></div>
    <div class="card-body">
      <label>Username</label>
      <input type="text" class="form-control" [(ngModel)]="username" /><br />
      <p>{{ username }}</p>
      <button
        class="btn btn-primary"
        [disabled]="username === ''"
        (click)="onReset($event)">
        Reset User
        <!-- '===' to validate; '=' to assign -->
        <!-- We could also use (click)="username = ' '" -->
      </button>
    </div>
  </div>
  <br /><br />
  <h3><b>Combining all forms of DataBinding</b></h3>
  <br />
  <p>
    Now, we want to display the server name inouted in the filed by the user
    just when we click in the button 'Add Server'. We start removing the
    <span class="code"
      >&lt;p>&lbrace; &lbrace;serverName&rbrace; &rbrace;&lt;/p></span
    >
    and update the Typescritp file:<br /><br />
    <span class="code no-border"
      >onCreateServer() &lbrace;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;this.serverCreationStatus = 'Server was created!
      Name is' + this.serverName;<br />
      &rbrace;</span
    ><br /><br />
    With that, we're using all four forms of Databinding together: an
    <b>event binding</b> to listen to the click, <b>string interpolation</b> to
    output the data, <b>property binding</b> to enable the button after 2s and
    <b>two-way binding</b> to fetch our input data.
  </p>
  <br /><br />
  <h3><b>Understanding Directives</b></h3>
  <br />
  <p>
    <b>What are directives ?</b><br />They're instructions in the DOM, e.g.
    components are kind of such instructions in the DOM. Once we place the
    selector of our component somewhere in our templates, at this point, we're
    instructing Angular to add the content of our component template, and the
    business logic in our TS file, in the place where we used the selector. So
    components are directives, but directives with a template <br /><br />
    <span class="code"
      >&lt;p appTurnGreen> Receives a green background!&lt;/p></span
    ><br /><br />
    <span class="code no-border">
      @Directive(&lbrace; <br />&nbsp;&nbsp;&nbsp;&nbsp;selector:
      '[appTurnGreen]' <br />&rbrace;)<br />
      export class TurnGreenDirective &lbrace;<br />&nbsp;&nbsp;&nbsp;&nbsp;...<br />&rbrace;
    </span>
    <br /><br />
    In the custom directive above, we typically add directives with attribute
    selector, but technically the selector of a directive can be configure just
    like the selector of a component. So Angular will fund this instruction,
    where we defined our directive with the
    <span class="code">@Directive</span> decorator and which holds the logic to
    'turn it green', in this case.
  </p>
  <br /><br />
  <h3><b>Using ngIf to Output Data Conditionally</b></h3>
  <br />
  <p>
    Continue with the <i>servers</i> component example, we now want to show the
    <i>'Server was created!</i> message conditioned to the button click. For
    that, we'll use <b><i>ngIf</i></b> builtin directive. It works like an
    <b><i>if</i></b> statement: <br /><br />
    <span class="code"
      >&lt;p &ast;ngIf="serverCreated">Server was created, server name
      is:&lbrace; &lbrace; serverName &rbrace; &rbrace;&lt;/p></span
    ><br /><br />
    <b><i>*ngIf</i></b> has a <b><i>*</i></b> because is a structure directive,
    it changes the structure of the DOM; It also must call a method with
    instruction returning true or false, adding or removing, in this case.
    <br /><br />
    <span class="code no-border">
      export class ServersComponent implements OnInit &lbrace;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;serverCreated = false; <br /><br />
      onCreateServer() &lbrace;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;this.serverCreated = true;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;this.serverCreationStatus = 'Server was created!
      Name is' + this.serverName;<br />
      &rbrace; </span
    ><br /><br />
  </p>
  <div class="card">
    <div class="card-header"><b>Result View</b></div>
    <div class="card-body"><app-servers></app-servers></div>
  </div>
  <br /><br />
  <h3><b>Enhancing ngIf with an Else Condition</b></h3>
  <br />
  <p>
    With our <i>server</i> component, we want to attribute
    <i>'No server was created!'</i> like an <b>else</b> statement to server
    creation: <br /><br />
    <span class="code">
      &lt;ng-template #noServer>&lt;p>No server was
      created&lt;/p>&lt;/ng-template> </span
    ><br /><br />
    Here we're holding the paragraph using a <b>local reference</b>
    <i>'#noServer'</i> (as a marker for now) and the directive
    <span class="code">&lt;ng-template></span>, which you can use to mark places
    in the DOM that you want to show conditionally <br /><br />
    To enhance the <b><i>*ngIf</i></b> with an <b><i>else</i></b> condition, we
    add the <b>local reference</b> name in the <b>"if"</b> paragraph: <br />
    <span class="code"
      >&lt;p &ast;ngIf="serverCreated; else noServer">Server was created, server
      name is:&lbrace; &lbrace; serverName &rbrace; &rbrace;&lt;/p></span
    >
  </p>
  <div class="card">
    <div class="card-header"><b>Result View</b></div>
    <div class="card-body"><app-servers></app-servers></div>
  </div>
  <br />
  You can also use just the 'reverse' check <b>(!)</b> in the <b>"if"</b> line
  code:<br />
  <span class="code">
    &lt;p &ast;ngIf="!serverCreated">Server was created, server name is:&lbrace;
    &lbrace; serverName &rbrace; &rbrace;&lt;/p>
  </span>
  <br /><br />
  <h3><b>Styling Elements Dynamically with ngStyle</b></h3>
  <br />
  <p>
    Other type of directives are attribute directives, which are call like this
    becasue kthey are really just look like normal HTML attributes
    <b>(whithout the *)</b>; Unlike structure directives, attribute directives
    <b>don't add or remove elements</b>, they only change the element
    <b>they were placed on</b><br /><br />
    In the <b><i>'server'</i></b> TS file, we'll turn in random the servers
    status:<br />
    <span class="code no-border">
      constructor() &lbrace;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;this.serverStatus = Math.random() > 0.5 ? 'online'
      : 'offline';<br />
      &rbrace;</span
    ><br /><br />
    Now, we want to change the background color depending on the server status.
    For that, in the <b><i>'server'</i></b> HTML, we can use the directive:<br /><br />
    <span class="code no-border">
      &lt;p &lbrack;ngStyle]="&lbrace;backgorundColor: getColor()&rbrace;">
      &lbrace; &lbrace; 'Server' &rbrace; &rbrace; with ID &lbrace; &lbrace;
      serverId &rbrace;&rbrace; is &lbrace; &lbrace; getServerStatus()
      &rbrace;&rbrace; &lt;/p> </span
    ><br />
    <span class="obs">Directives starting with 'ng' is a builtin directive</span
    ><br /><br />
    The directive is just the <span class="code">ngStyle</span>; the square
    <i>brackets [ ]</i> is <b>not</b> part of the directive, it indicates that
    we want to <b>bind some property on this directive</b> and this property
    name happens to also be <span class="code">ngStyle</span>. Property bidning
    and directives are different things.<br /><br />
    In the <b><i>'server'</i></b> TS file:<br />
    <span class="code no-border">
      getColor() &lbrace;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;return this.serverStatus === 'online' ? 'green' :
      'red'; <br />&rbrace;
    </span>
  </p>
  <div class="card">
    <div class="card-header"><b>Result View</b></div>
    <div class="card-body"><app-servers></app-servers></div>
  </div>
  <br /><br />
  <h3><b>Applying CSS Classes Dynamically with ngClass</b></h3>
  <br />
  <p>
    Still in the <b><i>'server'</i></b> HTML, we're also going to add
    <span class="code">ngClass</span>:<br /><br />
    <span class="code no-border"
      >&lt;p &lbrack;ngStyle]="&lbrace;backgorundColor: getColor()&rbrace;"
      &lbrack;ngClass]="&lbrace;online: serverStatus === 'online'&rbrace;">
      &lbrace; &lbrace; 'Server' &rbrace; &rbrace; with ID &lbrace; &lbrace;
      serverId &rbrace;&rbrace; is &lbrace; &lbrace; getServerStatus()
      &rbrace;&rbrace; &lt;/p></span
    ><br /><br />In <span class="code">[ngClass]</span>, we have the CSS class
    name <i>online</i> and next, the condition to add this class, only when the
    <i>serverStatus()</i> is <i>'online'</i><br /><br />
    While <span class="code">ngStyle</span> allows us <b>change</b> the CSS
    style itself, to <span class="code">ngClass</span> allows us to dynamically
    <b>add or remove</b> CSS classes. <br /><br />
    In the <b><i>'server'</i></b> TS file, we add the key 'styles' in the
    <span class="code">@Component</span> decorator with the CSS class we want to
    bind in the <span class="code">ngClass</span>:<br /><br />
    <span class="code no-border">
      @Component(&lbrace;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;selector: 'app-server',<br />
      &nbsp;&nbsp;&nbsp;&nbsp;templateUrl: './server.component.html',<br />
      &nbsp;&nbsp;&nbsp;&nbsp;styles: [`<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.online &lbrace;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color:
      white;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rbrace;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;`]<br />
      &rbrace;) </span
    ><br /><br />
    <b>Important:</b> In the <span class="code">@Component</span> decorator, we
    can have just <b>one</b> style key: <b><i>styleUrls</i></b> OR
    <b><i>styles</i></b
    ><br /><br />
  </p>
  <br /><br />
  <h3><b>Outputting Lists with ngFor</b></h3>
  <br />
  <p>
    Another builtin directive is <b>ngFor</b>, it allows us to update a certain
    list/array and output it in the DOM, for example.<br /><br />
    In the <b>'servers'</b> component, we're actually adding the servers
    manually:
    <span class="code no-border">
      &lt; app-server>&lt;/app-server><br />
      &lt; app-server>&lt;/app-server>
    </span>
    Now we want to update it with the input value after click the button 'Add
    Server'. <br />
    In the <b>'servers'</b> TS file, we'll add the property:
    <span class="code">servers = ['Testserver', 'Testserver 2'];</span
    ><br /><br />And in the <b><i>onCreateServer()</i></b
    >, we'll add: <span class="code">this.servers.push(this.serverName);</span
    ><br /><br />
    Since the <b><i>onCreateServer()</i></b> method is binded to the
    <i>(click)</i>event in the button, it will trigger the <i>push()</i> method
    and add the input value as a new server name in the array
  </p>
  <br /><br />
  <h3>
    <b
      >Assignment 3: Practicing Directives + Getting the Index when using
      ngFor</b
    >
  </h3>
  <br />
  <p>1. Add a button which says 'Display Details'</p>
  <p>
    2. Add a paragraph with any content of your choice (e.g. 'Secret Password =
    tuna')
  </p>
  <p>
    3. Toggle the displaying of that paragraph with the button created in the
    first step
  </p>
  <p>
    4. Log all button clicks in an array and output that array below the secret
    paragraph (maybe log a timestamp or simply an incrementing number)
  </p>
  <p>
    5. Starting at the 5th log item, give all future log items a blue background
    (via ngStyle) and white color (via ngClass)
  </p>
  <div class="card">
    <p class="card-header"><b>Result View</b></p>
    <div class="card-body">
      <!-- Easy way to toggle: -->
      <!-- <button class="btn btn-primary" (click)="showSecret = !showSecret">
        Display Details</button
      > -->
      <button class="btn btn-primary" (click)="onToggleDetails()">
        Display Details</button
      ><br />
      <p *ngIf="showSecret"><br />Secret Password = Spicy Tuna</p>
      <!-- <div
        *ngFor="let logItem of log;"
        [ngStyle]="{backgroundColor: logItem >= 5 ? 'blue' : 'inherit'}"
        [ngClass]="{'white-text': logItem >= 5}">
        {{ logItem }}
      </div> -->
      <!-- 'log' is the array created on the TS file - so it will loop/pass for all the item ('logItem') inside the array ('log') applicating the instructions passed on 'onToggleDetails()' until the array lenght is over -->

      <!-- Solution to index -->
      <div
        *ngFor="let logItem of log; let i = index"
        [ngStyle]="{backgroundColor: i >= 4 ? 'blue' : 'inherit'}"
        [ngClass]="{'white-text': i >= 4}">
        {{ logItem }}
      </div>
    </div>
  </div>
  <br /><br />
  <h3>
    <b>Project Introduction</b>
  </h3>
  <br />
  <p>Objective: Build a recipe book and a shopping list app</p>
  <br />
  <h3>Planning the App</h3>
  <br />
  <p>
    1. Layout the structure of the app and specially plan which components
    you're probably going to need
  </p>
  <!-- <svg focusable="false" aria-label="app">
    <use href="../assets/sprite.svg#Recipie-app-structure"></use>
  </svg> -->
  <img
    class="img-responsive d-flex m-auto"
    src="../assets/images/Recipie-app-structure.png" />
  <br /><br /><br />
  <h3>
    <b>Creating a New App Correctly</b>
  </h3>
  <br />
  <p>
    Make sure, you do create that app by also adding the
    <span class="code">--no-strict</span> flag to the
    <span class="code">ng new</span> command - otherwise you will run into
    issues later on (we'll still dive into that "Strict Mode" later in the
    course of course, no worries)!<br /><br />

    We'll also install the Bootstrap CSS Framework and in this course, we use
    version 3 of the framework. Install it via
    <span class="code">npm install --save bootstrap@3</span> => The
    <span class="code">@3</span> is important!<br /><br />

    Additionally, when using a project created with Angular CLI 6+ (check via ng
    v ), you'll have an <span class="code">angular.json</span> file instead of
    an <span class="code">.angular-cli.json</span> file. In that file, you still
    need to add Bootstrap to the <span class="code">styles[]</span> array as
    shown in the next video, but the path should be
    node_modules/bootstrap/dist/css/bootstrap.min.css , NOT
    ../node_modules/bootstrap/dist/css/bootstrap.min.css . The leading ../ must
    not be included.<br /><br />
    The project was created separately from this app. (<a
      href="http://localhost:4700/"
      >http://localhost:4700/</a
    >)
  </p>
  <br /><br />
  <h5><b>Our new app looks like this at this point ...</b></h5>
  <br />
  <p>
    We've created the project itself (ReciPie App) and the components as
    planned: the header component, the recipe and the shopping list components
    and its child components
  </p>
  <br />
  <img
    src="../assets/images/recipie-app-1.png"
    class="img-responsive d-flex m-auto" /><br />
  <br /><br />
  <h3><b>Alternative Non-Collapsable Navigation Bar</b></h3>
  <br />
  <p>
    The way we added it, the Navbar will collapse on smaller screens. Since we
    didn't implement a Hamburger menu, that means that there's no way of
    accessing our links on smaller screens. <br /><br />

    You can either add such a menu on your own (see below), or you replace
    <span class="code">collapse navbar-collapse</span> >with just
    <span class="code">navbar-default.</span>

    Adding a Hamburger Menu: <br /><br />
    Alternatively, if you want to make the navigation bar responsive, please
    replace these lines in
    <span class="code">header.component.html</span>:<br />
  </p>
  <pre>
    <code class="code no-border">
      &lt;div class=&quot;navbar-header&quot;&gt;
        &lt;a routerLink=&quot;/&quot; class=&quot;navbar-brand&quot;&gt;Recipe Book&lt;/a&gt;
      &lt;/div&gt;
      &lt;div class=&quot;collapse navbar-collapse&quot;&gt;
    </code>
  </pre>
  with these lines:
  <pre>
    <code class="code no-border">
      &lt;div class=&quot;navbar-header&quot;&gt;
        &lt;button type=&quot;button&quot; class=&quot;navbar-toggle&quot; (click)=&quot;collapsed = !collapsed&quot;&gt;
        &lt;span class=&quot;icon-bar&quot; *ngFor=&quot;let iconBar of [1, 2, 3]&quot;&gt;&lt;/span&gt;
        &lt;/button&gt;
        &lt;a routerLink=&quot;/&quot; class=&quot;navbar-brand&quot;&gt;Recipe Book&lt;/a&gt;
      &lt;/div&gt;
      &lt;div class=&quot;navbar-collapse&quot; [class.collapse]=&quot;collapsed&quot; (window:resize)=&quot;collapsed = true&quot;&gt;
    </code>
  </pre>

  and add this line to <span class="code">header.component.ts</span>:<br />
  <pre>
    <code class="code no-border">
      collapsed = true;
    </code>
  </pre>
  <br /><br />
  <h3><b> Creating a Model</b></h3>
  <br />
  <p>
    A model is a Typescript file where you define how an object should look like
    whatever you use it, in this project case, a recipe.<br /><br />In the
    component folder, we created a <span class="code">.model.ts</span> file:
  </p>
  <pre>
    <code class="code no-border">
      export class Recipe &lbrace;
        public name: string;
        public description: string;
        public imagePath: string;
        
        constructor(name: string, desc: string, imagePath: string) &lbrace;
          this.name = name;
          this.description = desc;
          this.imagePath = imagePath;
        &rbrace;
      &rbrace;
    </code>
  </pre>
  <p>A model is just a blueprint for objects we create</p>
  <br /><br />
  <h3><b>Adding Content to the Recipes Components (using model)</b></h3>
  <br />
  <p>In the <span class="code">recipe-list.component.ts</span>, we add:</p>
  <pre>
    <code class="code no-border">
      export class RecipeListComponent implements OnInit &lbrace;
        recipes: Recipe[] = [
          new Recipe(
            'A Test Recipe',
            'This is simply a test',
            'https://www.supergoldenbakes.com/wordpress/wp-content/uploads/2019/10/Hungarian_Goulash_s.jpg'
          ),
        ];
      
        constructor() &lbrace;&rbrace;
        ngOnInit(): void &lbrace;&rbrace;
      &rbrace;
    </code>
  </pre>
  <p>
    The <span class="code">Recipe[]</span> became the type of the property (our
    won property), like <span class="code">name: string</span><br /><br />
    Now the TS 'knows' that the only thing which will get stored in this
    <span class="code">recipes</span> property is an array, which holds a couple
    of recipe object. <br /><br />
    In the method <span class="code">new Recipe()</span>, we passed the
    parameters that we defined in the <span class="code">model.ts</span>: the
    name, the description and the image. <br /><br />
    To informe TS where this type <span class="code">Recipes</span> is coming
    from, we add at <span class="code">recipe-list.component.ts</span>:
  </p>
  <pre>
    <code class="code no-border">
      import &lbrace; Recipe &rbrace; from &apos;../recipe.model&apos;
    </code>
  </pre>
  <p>
    To see that output, we're going to add a
    <span class="code">*ngFor=&quot;let recipe of recipes&quot;</span> in the
    embracing tag <span class="code">&lt;a></span> that holds the object
    properties (name, description and image) and now we can access the arguments
    and use the <b>string interpolation</b> to add the values dinamically
  </p>
  <pre>
    <code class="code no-border">
      &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-xs-12&quot;&gt;
          &lt;button class=&quot;btn btn-success&quot;&gt;New Recipe&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-xs-12&quot;&gt;
          &lt;a href=&quot;#&quot; class=&quot;list-group-item clearfix&quot; *ngFor=&quot;let recipe of recipes&quot;&gt;
            &lt;div class=&quot;pull-left&quot;&gt;
              &lt;h4 class=&quot;list-group-item-heading&quot;&gt;&lbrace; &lbrace; recipe.name &rbrace; &rbrace;&lt;/h4&gt;
              &lt;p class=&quot;list-group-item-text&quot;&gt;&lbrace; &lbrace; recipe.description &rbrace; &rbrace;&lt;/p&gt;
            &lt;/div&gt;
            &lt;span class=&quot;pull-right&quot;&gt;
              &lt;img
                [src]=&quot;recipe.imagePath&quot;
                alt=&quot;&lbrace; &lbrace; recipe.name &rbrace; &rbrace; &quot;
                class=&quot;img-responsive&quot;
                style=&quot;max-height: 50px&quot;
              /&gt;
            &lt;/span&gt;
            &lt;!-- we could use also src=&quot;&lbrace; &lbrace; recipe.imagePath &rbrace; &rbrace;&quot;  --&gt;
          &lt;/a&gt;
          &lt;app-recipe-item&gt;&lt;/app-recipe-item&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    </code>
  </pre>
  <img
    src="../assets/images/recipie-app-2.png"
    class="img-responsive d-flex m-auto"
    style="width: 100%" /><br /><br /><br /><br />
  <p>
    If we add more <span class="code">new Recipe()</span> methods in the
    <span class="code">recipe-list.component.ts</span>, it will successfull
    multplicate it in the output <br /><br />
    <img
      src="../assets/images/recipie-app-2.2.png"
      class="img-responsive d-flex m-auto" /><br />
  </p>
  <br /><br />
  <h3><b>Displaying Recipe Details</b></h3>
  <br />
  <p>
    For now, we just added a layout for these details in the
    <span class="code">recipe-details.component.html</span>, discovering later
    how to stablish communication between to components, to for example, click
    on the recipe on the left (<span class="code no-border"
      >recipe-list.component</span
    >), and show the ingredients (<span class="code no-border"
      >recipe-item.component</span
    >) and images on the right (<span class="code no-border"
      >recipe-details.component</span
    >):
  </p>
  <br />
  <img
    src="../assets/images/recipie-app-3.png"
    alt=""
    class="img-responsive d-flex m-auto" /><br /><br />
  <br /><br />
  <h3><b> Working on the ShoppingListComponent</b></h3>
  <br />
  <p>
    At the <span class="code">shopping-list.component.html</span>, we adjust the
    layout to receive a list of ingredients:
  </p>
  <pre>
  <code class="code no-border">
    &lt;div class=&quot;row&quot;&gt;
      &lt;div class=&quot;col-xs-10&quot;&gt;
        &lt;app-shopping-edit&gt;&lt;/app-shopping-edit&gt;
        &lt;hr /&gt;
        &lt;ul class=&quot;list-group&quot;&gt;
          &lt;a class=&quot;list-group-item&quot; style=&quot;cursor: pointer&quot;&gt;&lt;/a&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  </code>
</pre>
  <p>
    And in the <span class="code">shopping-list.component.ts</span>, we added a
    property <span class="code"> ingredients = [];</span> that will receive the
    ingredients array and since we're going to use <i>ingredients</i> with a
    certain frenquency, it makes sense to create a model for that.<br /><br />
    In the <i>app</i> folder, we created a new folder call
    <span class="code">shared</span>. It will contain features or elements of
    the app which are shared across different features, like the ingridient,
    which we're going to use in two or more different components.<br /><br />
    Inside this folder, we're going to create the
    <span class="code">ingredient.model.ts</span>, with the structure:
  </p>
  <pre>
    <code class="code no-border">
      export class Ingredient &lbrace;
        constructor(public name: string, public amount: number) &lbrace;&rbrace;
      &rbrace;
    </code>
  </pre>
  <p>This is a short and easy way to declare an model</p>
  <br /><br />
  <h3><b>Creating and Outputting the Shopping List</b></h3>
  <br />
  <p>
    Now, let's import <span class="code">ingredient.model.ts</span> into the
    <span class="code">shopping-list.component.ts</span>:
  </p>
  <pre>
    <code class="code no-border">
      import &lbrace; Ingredient &rbrace; from '../shared/ingredient.model';

      export class ShoppingListComponent implements OnInit &lbrace;
        ingredients: Ingredient[] = [
          new Ingredient('Apples', 5),
          new Ingredient('Tomatoes', 10)
        ];
      &rbrace;
    </code>
  </pre>
  <p>
    We're going to outputting this data in the
    <span class="code">shopping-list.component.html</span> through the
    <span class="code">*ngFor</span> directive to loop all over the array items
    we added in the <span class="code">shopping-list.component.ts</span> and
    <b>string interpolation</b> in the
    <span class="code">shopping-list.component.html</span> to output item by
    item:
  </p>
  <pre>
    <code class="code no-border">
      &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-xs-10&quot;&gt;
          &lt;app-shopping-edit&gt;&lt;/app-shopping-edit&gt;
          &lt;hr /&gt;
          &lt;ul class=&quot;list-group&quot;&gt;
            &lt;a
              class=&quot;list-group-item&quot;
              style=&quot;cursor: pointer&quot;
              *ngFor=&quot;let ingredient of ingredients&quot;
              &gt;&lbrace; &lbrace; ingredient.name &rbrace; &rbrace; (&lbrace; &lbrace; ingredient.amount &rbrace; &rbrace;)&lt;/a
            &gt;
          &lt;/ul&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    </code>
  </pre>
  <img
    src="../assets/images/recipie-app-4.png"
    alt=""
    class="img-responsive d-flex m-auto" /><br /><br />
  <br /><br />
  <h3><b>Adding a Shopping List Edit Section</b></h3>
  <br />
  <p>
    To <span class="code">shopping-edit.component</span>, we adjusted the HTML
    structure:
  </p>
  <pre>
    <code class="code no-border">
      &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-xs-12&quot;&gt;
          &lt;form&gt;
            &lt;div class=&quot;row&quot;&gt;
              &lt;div class=&quot;col-sm-5 form-group&quot;&gt;
                &lt;label for=&quot;name&quot;&gt;Name&lt;/label&gt;
                &lt;input type=&quot;text&quot; id=&quot;name&quot; class=&quot;form-control&quot; /&gt;
              &lt;/div&gt;
              &lt;div class=&quot;col-sm-2 form-group&quot;&gt;
                &lt;label for=&quot;amount&quot;&gt;Amount&lt;/label&gt;
                &lt;input type=&quot;text&quot; id=&quot;Amount&quot; class=&quot;form-control&quot; /&gt;
              &lt;/div&gt;
            &lt;/div&gt;
            &lt;br /&gt;
            &lt;div class=&quot;row&quot;&gt;
              &lt;div class=&quot;col-xs-12&quot;&gt;
                &lt;button class=&quot;btn btn-success&quot; type=&quot;submit&quot;&gt;Add&lt;/button&gt;
                &lt;button class=&quot;btn btn-danger&quot; type=&quot;button&quot;&gt;Delete&lt;/button&gt;
                &lt;button class=&quot;btn btn-primary&quot; type=&quot;button&quot;&gt;Clear&lt;/button&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/form&gt;
        &lt;/div&gt;
      &lt;/div&gt;      
    </code>
  </pre>
  <img
    src="../assets/images/recipie-app-5.png"
    alt=""
    class="img-responsive d-flex m-auto" /><br /><br />
  <br /><br />
  <h3><b>Understanding Angular Error Messages</b></h3>
  <br />
  <p>
    <b>1.</b> Get used to have your console (dev. tools) opened, so you can
    follow up what's happening <br /><br />
    <b>2.</b> You can identify the error by the file name, the line number
    pointed (not the exactly line, but works like a clue) and usually the
    console will tell you the cause too - like 'Cannot read property X', or 'X
    method is not defined', etc.. <br /><br /><b>3.</b> The UI interaction can
    be a clue too, like a button click, a key press - this kind of event can be
    attached to the error trigger <br /><br /><b>4.</b> Don't forget to define
    your property (e.g. <span class="code">name: string;</span>), not just
    declare it (e.g. <span class="code">name;</span>)
  </p>
  <br /><br />
  <h3><b>Debugging Code in the Browser Using Sourcemaps</b></h3>
  <br />
  <p>
    Sometimes reading the error messages is not enough, or you don't even get a
    error message, like getting a logical error in the code. <br /><br />
    In the browser dev. tools, you can access the
    <span class="code">Sources</span> tab with all the script bundles related to
    the app and add a break point in the line maybe is responsible for the
    issue, in the <span class="code">main.bundle</span>, for example, that like
    the name says, its the main script source of your app. This problably will
    access the TS file related to that line, and since Typescript doesn't run in
    the browser, that's possible because these bundles supports source maps,
    that's is added to the bundles by the CLI. It allow the browser to translate
    the JS code to TS code, or map the JS code to TS files. <br /><br />
    The debugger will run step by step according to the logic of your code,
    pausing before each step so you can see what's happening in the code while
    runtime and identify the error.<br /><br />
    Running the entire main.bundle can be hard, so you can access the TS files
    in the <span class="code">webpack</span> folder in the web dev. tools 🤡
  </p>
  <br /><br />
  <h3><b>Splitting Apps into Components</b></h3>
  <br />
  <p>
    For this lecture, we've created a new app
    <span class="code">cmd-databinding-start</span> to explore components and
    databinding along the project
  </p>
  <img
    src="../assets/images/cmp-databinding-1.png"
    alt=""
    class="img-responsive d-flex m-auto" /><br /><br />
  <p>
    To enhance the app structure, we're going to split the app logic into
    components, avoiding concentrate all the methods just in the
    <span class="code">app.component</span>, so we could reuse it and it'll be a
    lot easier to update and do maintenance.
  </p>
  <p>
    We've created 2 new components at the
    <span class="code">app.component</span> folder: the
    <span class="code">cockpit.component</span>, to where we moved the part of
    the 'CRUD' and the <span class="code">server-element.component</span>, to
    where we moved the content which will receive the new servers created. Now
    we need to pass data from <span class="code">cockpit.component</span> to ➡
    <span class="code">server-element.component</span>
  </p>
  <br /><br />
  <h3><b>Property & Event Binding Overview</b></h3>
  <br />
  <p>
    Somehow, when we used the property and event binding back there, we're
    passing ans receiving 'data' too. We can use Native Properties & Events from
    the <b>HTML elements</b>; We can use Custom Properties & Events from the
    <b>Directives</b>, like we already did with
    <span class="code">ngClass</span> and <span class="code">ngStyle</span>; And
    finally we can also use our own Custom Properties & Events from our own
    <b>Components</b>
  </p>
  <br /><br />
  <h3><b>Binding to Custom Properties</b></h3>
  <br />
  <p>
    To output the servers/blueprint created, the
    <span class="code">app.component</span> need to access the
    <span class="code">server-element.component</span>, so it need to be
    accessible from outside of its own component. But first, we moved the
    <span class="code">element</span> property definiton to the
    <span class="code">server-element.component.ts</span> file, since we're
    adjusting the app logic to separated components.
  </p>
  <pre>
    <h5>server-element.component.html</h5>
    <code class="code no-border">
      &lt;div class=&quot;panel panel-default&quot;&gt;
        &lt;div class=&quot;panel-heading&quot;&gt;&lbrace; &lbrace; element.name &rbrace; &rbrace;&lt;/div&gt;
        &lt;div class=&quot;panel-body&quot;&gt;
          &lt;p&gt;
            &lt;strong *ngIf=&quot;element.type === &apos;server&apos;&quot; style=&quot;color: red&quot;&gt; &lbrace; &lbrace;
              element.content
            &rbrace; &rbrace;&lt;/strong&gt;
            &lt;em *ngIf=&quot;element.type === &apos;blueprint&apos;&quot;&gt;&lbrace; &lbrace; element.content &rbrace; &rbrace;&lt;/em&gt;
          &lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    </code>
  </pre>
  <pre>
    <h5>server-element.component.ts</h5>
    <code class="code no-border">
      export class ServerElementComponent &lbrace;
        element: &lbrace; type: string; name: string; content: string &rbrace;
      &rbrace;
    </code>
  </pre>
  <p>
    <i>Type</i>, <i>name</i> and <i>content</i> are not values, they're like
    property types. Values must be in the 'right' side of the equal sign '=';
    Before that '=', we're defining types.
  </p>
  <p>
    In the <span class="code">app.component.ts</span>, we create the array that
    will be looped in the <span class="code">app.component.ts</span> with the
    property values:
  </p>
  <pre>
    <code class="code no-border">
      export class AppComponent &lbrace;
        serverElements = [
          &lbrace; type: 'server', name: 'Testserver', content: 'Just a test!' &rbrace;,
        ];
      &rbrace;
    </code>
    <span class="obs">Here, the keys inside the &lbrace; &rbrace; represent values because they're in the 'right' side if the '=' sign</span>
  </pre>
  <p>
    But the <span class="code">app.component.ts</span> still need access to the
    <span class="code">server-element.component</span> to fetch the
    <span class="code">element</span> property, which defines the properties and
    these property types, and bind it to the
    <span class="code">server-element</span> HTML structure, that will be part
    of the view in the UI. We could bind the
    <span class="code">element</span> property in the
    <span class="code">app.component</span> HTML:
    <span class="code">&lbrack;element&rbrack;="serverElement"</span>, but we
    still couldn't access it because properties it'd still just accessible for
    its own component, not from the outside. <br /><br />
    So we have to be explicit about which properties you want to expose. If you
    want to allow parent components to be able to bind this property, you need
    to add the <span class="code">@Input</span> decorator (and also import it in
    the component which its being declared). Now any aprent component, or any
    component hosting the
    <span class="code">server-element.component</span> (implemeting it through
    its selector) is able to bind the <span class="code">element</span> property
    <br /><br />
    <img
      src="../assets/images/cmp-databinding-2.png"
      alt=""
      class="img-responsive d-flex m-auto" /><br /><br />
  </p>
  <br /><br />
  <h3><b>Assigning an Alias to Custom Properties</b></h3>
  <br />
  <p>
    To avoid using the same property name inside and outside the component, you
    can pass an argument to <span class="code">@Input</span> with the property
    name as you want to have it outside of this component: <br /><br />
    <span class="code">@Input('srvElement')</span><br /><br />
    And outside bind it like this:
    <span class="code">&lbrack;srvElement&rbrack;="serverElement"</span>
  </p>
  <br /><br />
  <h3><b>Binding to Custom Events</b></h3>
  <br />
  <p>
    We learned how to pass data from a component down to another component which
    was implemented there. Now we want to do the reverse, we want to inform the
    parent component that some event happened in the inner component. For
    example, we got the <span class="code">cockpit.component</span> selector
    implemented in the <span class="code">app.component</span> HTML, and in the
    <span class="code">cockpit.component</span> we have 2 buttons. When its
    clicked, a new server/blueprint is created. And we want to inform our parent
    component <span class="code">app.component</span> when this happen.
    <br /><br />
    So we copy the methods from <span class="code">cockpit.component</span> TS
    file to <span class="code">app.component</span> TS file and make some
    adjustment:
  </p>
  <pre>
    <h5>app.component.ts</h5>
    <code class="code no-border">
      onServerAdded(serverData: &lbrace; serverName: string; serverContent: string &rbrace;) &lbrace;
        this.serverElements.push(&lbrace;
          type: &apos;server&apos;,
          name: serverData.serverName,
          content: serverData.serverContent,
          &rbrace;);
          &rbrace;
    
      onBlueprintAdded(blueprintData: &lbrace;
        serverName: string;
        serverContent: string;
        &rbrace;) &lbrace;
        this.serverElements.push(&lbrace;
          type: &apos;blueprint&apos;,
          name: blueprintData.serverName,
          content: blueprintData.serverContent,
          &rbrace;);
          &rbrace;
    </code>
  </pre>
  <pre>
    <h5>app.component.html</h5>
    <code class="code no-border">
      &lt;div class=&quot;container&quot;&gt;
        &lt;app-cockpit (serverCreated)=&quot;onServerAdded($event)&quot; (blueprintCreated)=&quot;onBlueprintAdded($event)&quot;&gt;&lt;/app-cockpit&gt;
        &lt;hr /&gt;
        &lt;div class=&quot;row&quot;&gt;
          &lt;div class=&quot;col-xs-12&quot;&gt;
            &lt;app-server-element
              *ngFor=&quot;let serverElement of serverElements&quot;
              [srvElement]=&quot;serverElement&quot;
            &gt;&lt;/app-server-element&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    </code>
  </pre>
  <p>
    In the <span class="code">cockpit.component.ts</span> we need to emit our
    own event, so we add to new properties:
  </p>
  <pre>
    <code class="code no-border">
      export class CockpitComponent &lbrace;
        serverCreated = new EventEmitter&lt;&gt;;
        blueprintCreates = new EventEmitter&lt;&gt;;
        &rbrace;
    </code>
  </pre>
  <p>
    This <span class="code">new EventEmitter</span> indicated in Typescript by
    using this <span class="code">&lt;&gt;</span> sign, the type of the event
    data you're going to emit. And we need these <span class="code">()</span> at
    the end to call the constructor of EventEmitter and create a new
    EventEmitter object, which is now stored in
    <span class="code">serverCreated</span>. It allows you to emit your own
    events. *It also need to be imported, but generally Angular import
    automatically as soon as you write the method name.
  </p>
  <pre>
    <h5>cockpit.component.ts</h5>
    <code class="code no-border">
      import &lbrace; Component, EventEmitter &rbrace; from &apos;@angular/core&apos;;

        @Component(&lbrace;
          selector: &apos;app-cockpit&apos;,
          templateUrl: &apos;./cockpit.component.html&apos;,
          styleUrls: [&apos;./cockpit.component.css&apos;],
        &rbrace;)
        export class CockpitComponent &lbrace;
          serverCreated = new EventEmitter&lt;&lbrace;
            serverName: string;
            serverContent: string;
          &rbrace;&gt;();
          blueprintCreated = new EventEmitter&lt;&lbrace;
            serverName: string;
            serverContent: string;
          &rbrace;&gt;();
          newServerName = &apos;&apos;;
          newServerContent = &apos;&apos;;

          onAddServer() &lbrace;
            this.serverCreated.emit(&lbrace;
              serverName: this.newServerName,
              serverContent: this.newServerContent,
            &rbrace;);
          &rbrace;

          onAddBlueprint() &lbrace;
            this.blueprintCreated.emit(&lbrace;
              serverName: this.newServerName,
              serverContent: this.newServerContent,
            &rbrace;);
          &rbrace;
        &rbrace;
    </code>
  </pre>
  <p>
    With all that, we're emitting our own events but we need to make our event
    methods 'listenable' from outside adding
    <span class="code">@Output()</span> decorator (<span class="code"
      >@Input()</span
    >
    make properties being 'bindable' outside).
  </p>
  <pre>
    <code class="code no-border">
      @Output() serverCreated = new EventEmitter&lt;&lbrace;
        serverName: string;
        serverContent: string;
      &rbrace;&gt;();

      @Output() blueprintCreated = new EventEmitter&lt;&lbrace;
        serverName: string;
        serverContent: string;
      &rbrace;&gt;();

    </code>
  </pre>
  <img
    src="../assets/images/cmp-databinding-3.png"
    alt=""
    class="img-responsive d-flex m-auto" /><br /><br />
  <br /><br />
  <h3><b>Assigning an Alias to Custom Events</b></h3>
  <br />
  <p>
    Just like we did with <span class="code">@Input</span>, we can also create a
    specific alias for them to use it outside the component
  </p>
  <pre>
    <h5>cockpit.component.ts</h5>
    <code class="code no-border">
      @Output('svrCreated') serverCreated = new EventEmitter&lt;&lbrace;
        serverName: string;
        serverContent: string;
      &rbrace;&gt;();

      @Output('bpCreated') blueprintCreated = new EventEmitter&lt;&lbrace;
        serverName: string;
        serverContent: string;
      &rbrace;&gt;();
    </code>
    <h5>app.component.html</h5>
    <code class="code no-border">
      &lt;app-cockpit
        (svrCreated)=&quot;onServerAdded($event)&quot;
        (bpCreated)=&quot;onBlueprintAdded($event)&quot;
      &gt;&lt;/app-cockpit&gt;
    </code>
  </pre>
  <br /><br />
  <h3><b>Custom Property and Event Binding Summary</b></h3>
  <br />
  <ul>
    <li>
      <span class="code">@Input</span> - It's a key feature to components
      communication and make properties bindable from outside from the parent
      component
    </li>
    <li>
      <span class="code">@Output</span> - Allows parent components using this
      components to listen to your own events which you created with
      <span class="code">new EventEmitter&lt;&lbrace;&rbrace;&gt;</span>
    </li>
  </ul>
  <br /><br />
  <h3><b>Understanding View Encapsulation</b></h3>
  <br />
  <p>
    Angular treats the CSS files in an encapsulate way, which is not the browser
    default behavior. The rules inside of the CSS file in the component folder
    will work just in that component, ignoring the general rule of the CSS, that
    apply your style in every element with that div, #id, .class, tag ...<br /><br />
    Angular divide its elements by style attributes. So paragraphs with the same
    Angular attributes (attributes injected by Angular itself, which can be seen
    in the console) receive the same style refered to that attribute. It
    emulates the shadow DOM, a technology not support by the most browsers.
  </p>
  <br /><br />
  <h3><b>More on View Encapsulation</b></h3>
  <br />
  <p>
    We can overrride this encapsultion adding
    <span class="code">encapsulation: ViewEncapsulation.None</span> at the
    <span class="code">component.ts</span> file decorator of your component.
    <br />
    It will turn your CSS styles into global rules. <br /><br />
    You can also use
    <span class="code">encapsulation: ViewEncapsulation.ShadowDom</span>, it
    will gives you the same result as before overriding encapsulation, but
    emulating only in supported browsers. <br />
    <span class="code">encapsulation: ViewEncapsulation.Emulated</span> will
    return the default result.
  </p>
  <br /><br />
  <h3><b>Using Local References in Templates</b></h3>
  <br />
  <p>
    A local reference can be used in any HTML element by adding a
    <span class="code">#</span> and attributing a name for it <br /><br />
    <span class="code"
      >&lt;input type="text" class="form-control" #serverNameInput/></span
    ><br /><br />
    And its use to hold a reference to this HTML element whit all its
    properties. We can see it passing as argument to the
    <span class="code"
      >&lt;button class="btn btn-primary"
      &lpar;click&rpar;="onAddServer(serverNameInput)">Add
      Server&lt;/button></span
    ><br /><br />You can use <span class="code">#serveNameInput</span> only in
    your template, not in the TS file of your component. But in your TS file,
    now you need to add a parameter to the method you included
    <span class="code">#serveNameInput</span>
  </p>
  <pre>
    <code class="code no-border">
      onAddServer(nameInput) &lbrace;
        console.log(nameInput);
        this.serverCreated.emit(&lbrace;
          serverName: this.newServerName,
          serverContent: this.newServerContent,
          &rbrace;);
      &rbrace;
    </code>
  </pre>
  <img
    src="../assets/images/cmp-databinding-4.png"
    alt=""
    class="img-responsive d-flex m-auto" /><br /><br />
  The input displayed on the console is the exactly HTML element with all its
  properties that we added the
  <span class="code">#serveNameInput</span> and passed it as argument (and
  parameter in the TS file) to the <i>Add Server</i> button.<br />
  If we add <span class="code">.value</span> to
  <span class="code">console.log(nameInput.value);</span> we can get just the
  value typed on the field:
  <pre>
    <code class="code no-border">
      onAddServer(nameInput) &lbrace;
        console.log(nameInput.value);
        this.serverCreated.emit(&lbrace;
          serverName: this.newServerName,
          serverContent: this.newServerContent,
        &rbrace;);
      &rbrace;
    </code>
  </pre>
  <img
    src="../assets/images/cmp-databinding-5.png"
    alt=""
    class="img-responsive d-flex m-auto" /><br /><br />
  <p>
    To use this data in the template as server/blueprint server name, we can
    adjust the <span class="code">serverName:</span> property TS file:
  </p>
  <pre>
    <code class="code no-border">
      onAddServer(nameInput: HTMLInputElement) &lbrace;
        this.serverCreated.emit(&lbrace;
          serverName: nameInput.value,
          serverContent: this.newServerContent,
        &rbrace;);
      &rbrace;
    
      onAddBlueprint(nameInput: HTMLInputElement) &lbrace;
        this.blueprintCreated.emit(&lbrace;
          serverName: nameInput.value,
          serverContent: this.newServerContent,
        &rbrace;);
      &rbrace;
    </code>
  </pre>
  <br /><br />
  <h3><b>@ViewChild() in Angular 8+</b></h3>
  <br />
  <p>
    In Angular 8+, the <span class="code">@ViewChild()</span> syntax which
    you'll see in the next lecture needs to be changed slightly:<br /><br />

    Instead of:<br />

    <span class="code"
      >@ViewChild('serverContentInput') serverContentInput: ElementRef;</span
    >
    use<br /><br />

    <span class="code"
      >@ViewChild('serverContentInput', &lbrace;static: true&rbrace;)
      serverContentInput: ElementRef;</span
    ><br /><br />
    The same change (add
    <span class="code">&lbrace; static: true &rbrace;</span> as a second
    argument) needs to be applied to ALL usages of<span class="code">
      @ViewChild()</span
    >
    (and also <span class="code">@ContentChild()</span> which you'll learn about
    later) IF you plan on accessing the selected element inside of
    <span class="code">ngOnInit()</span>.<br /><br />
    If you DON'T access the selected element in
    <span class="code">ngOnInit</span> (but anywhere else in your component),
    set <span class="code">static: false</span> instead! <br /><br />
    If you're using Angular 9+, you only need to add
    <span class="code">&lbrace; static: true &rbrace; </span> (if needed) but
    not <span class="code">&lbrace; static: false &rbrace;</span>.
  </p>
  <br /><br />
  <h3><b>Getting Access to the Template & DOM with @ViewChild</b></h3>
  <br />
  <p>
    There is another way of gettinf access to local references or to any
    element, directly from within our Typescript code, like getting access
    before calling a meth
  </p>

  <pre>
      <h5>cockpit.component.html</h5>
      <code class="code no-border">
        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; #serverContentInput /&gt;
      </code>
    </pre>
  <pre>
      <h5>cockpit.component.ts</h5>
      <code class="code no-border">
        @ViewChild(&apos;serverContentInput&apos;, &lbrace; static: true &rbrace;)
        serverContentInput: ElementRef;
      
        onAddServer(nameInput: HTMLInputElement) &lbrace;
          this.serverCreated.emit(&lbrace;
            serverName: nameInput.value,
            serverContent: this.serverContentInput.nativeElement.value,
          &rbrace;);
        &rbrace;
      
        onAddBlueprint(nameInput: HTMLInputElement) &lbrace;
          this.blueprintCreated.emit(&lbrace;
            serverName: nameInput.value,
            serverContent: this.serverContentInput.nativeElement.value,
          &rbrace;);
        &rbrace;
      </code>
    </pre>
  <p>
    The <span class="code">@ViewChild()</span> receives the element selector, in
    this case, we used the local reference
    <span class="code">#serverContentInput</span> or could receive a component
    name too (since this component is a child component). <br /><br />
    We get the same result in a different way.
  </p>
  <img
    src="../assets/images/cmp-databinding-6.png"
    alt=""
    class="img-responsive d-flex m-auto" /><br /><br />
  <br /><br />
  <h3><b>Projecting Content into Components with ng-content</b></h3>
  <br />
  <p>
    Another way to pass data is the directive
    <span class="code">&lt;ng-content&gt;&lt;/ng-content&gt;</span>. It serves
    as a hook you can place in your component to mark the place for Angular
    where it should add any content it finds between the opening and closing
    tag.
  </p>
  <pre>
    <h5>app.component.html</h5>
    <code class="code no-border">
      &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-xs-12&quot;&gt;
          &lt;app-server-element
            *ngFor=&quot;let serverElement of serverElements&quot;
            [srvElement]=&quot;serverElement&quot;
          &gt;
            &lt;p&gt;
              &lt;strong *ngIf=&quot;serverElement.type === &apos;server&apos;&quot; style=&quot;color: red&quot;&gt;&lbrace; &lbrace;
                serverElement.content
              &rbrace;&rbrace;&lt;/strong&gt;
              &lt;em *ngIf=&quot;serverElement.type === &apos;blueprint&apos;&quot;&gt;&lbrace; &lbrace;
                serverElement.content
              &rbrace;&rbrace;&lt;/em&gt;
            &lt;/p&gt;
          &lt;/app-server-element&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    </code>
  </pre>
  <pre>
    <h5>server-element.component.html</h5>
    <code class="code no-border">
      &lt;div class=&quot;panel-body&quot;&gt;
        &lt;ng-content&gt;&lt;/ng-content&gt;
      &lt;/div&gt;
    </code>
  </pre>
  <br /><br />
  <h3><b>Understanding the Component Lifecycle</b></h3>
  <br />
  <p>
    Angular supports a couple of lifecycle hooks. If a new component is created
    in Angular, once a new component is instantiated, Angular goes through a
    couple of different phases in this creation proccess. And it will actually
    give us a chance to hook into these phases and execute some code. We can
    hook into these phases by implementing some methods and Angular will call,
    if they're present.<br /><br />
    <b>1:</b> <span class="code">ngOnChanges</span> - Called after a bound input
    property changes. It's used when a new component is created and always when
    properties with <span class="code">@Input</span> decorator receives a new
    values.<br /><br />
    <b>2:</b> <span class="code">ngOnInit</span> - Called once the component is
    initialized, it runs after the constructor<br /><br />
    <b>3:</b><span class="code">ngDoCheck</span> - Called during every change
    detection run, when it need to change something in the template and can be
    trigger by a click, or a timer, or a observable<br /><br />
    <b>4:</b><span class="code">ngAfterContentInit</span> - Called after content
    (ng-content) has been projected into view <br /><br />
    <b>5:</b><span class="code">ngAfterContentChecked</span> - Called every time
    the projected content has been checked<br /><br />
    <b>6:</b><span class="code">ngAfterViewInit</span> - Called after the
    component's view (and child views) has been initialized<br /><br />
    <b>7:</b><span class="code">ngAfterViewChecked</span> - Called every time
    the view (and child views) have been checked<br /><br />
    <b>8:</b><span class="code">ngOnDestroy</span> - Called once the component
    is about to be destroyed (e.g. a *ngIf returning false and its removed from
    the DOM)<br /><br />
  </p>
  <br /><br />
  <h3><b>Seeing Lifecycle Hooks in Action</b></h3>
  <br />
  <p>
    <b>TIP:</b> <span class="code">ngOnChanges</span> is the only hook that
    receives arguments
  </p>
  <pre>
    <h5>server-element.component.ts</h5>
    <code class="code no-border">
      import &lbrace;
        AfterContentChecked,
        AfterContentInit,
        AfterViewChecked,
        AfterViewInit,
        Component,
        DoCheck,
        Input,
        OnChanges,
        OnDestroy,
        OnInit,
        SimpleChanges,
        ViewEncapsulation,
      &rbrace; from &apos;@angular/core&apos;;
      
      @Component(&lbrace;
        selector: &apos;app-server-element&apos;,
        templateUrl: &apos;./server-element.component.html&apos;,
        styleUrls: [&apos;./server-element.component.css&apos;],
      &rbrace;)
      export class ServerElementComponent
        implements
          OnInit,
          OnChanges,
          DoCheck,
          AfterContentInit,
          AfterContentChecked,
          AfterViewInit,
          AfterViewChecked,
          OnDestroy
      &lbrace;
        @Input(&apos;srvElement&apos;) element: &lbrace; type: string; name: string; content: string &rbrace;;
        @Input() name: string;
        constructor() &lbrace;
          console.log(&apos;constructor called&apos;);
        &rbrace;
      
        ngOnChanges(changes: SimpleChanges) &lbrace;
          console.log(&apos;ngOnChanges called&apos;);
          console.log(changes);
        &rbrace;
      
        ngOnInit() &lbrace;
          console.log(&apos;ngOnInit called&apos;);
        &rbrace;
      
        ngDoCheck(): void &lbrace;
          console.log(&apos;ngDoCheck called&apos;);
        &rbrace;
      
        ngAfterContentInit(): void &lbrace;
          console.log(&apos;ngAfterContentInit called&apos;);
        &rbrace;
      
        ngAfterContentChecked(): void &lbrace;
          console.log(&apos;ngAfterContentChecked called&apos;);
        &rbrace;
      
        ngAfterViewInit(): void &lbrace;
          console.log(&apos;ngAfterViewInit called&apos;);
        &rbrace;
      
        ngAfterViewChecked(): void &lbrace;
          console.log(&apos;ngAfterViewChecked called&apos;);
        &rbrace;
      
        ngOnDestroy(): void &lbrace;
          console.log(&apos;ngOnDestroy called&apos;);
        &rbrace;
      &rbrace;      
    </code>
  </pre>
  <img
    src="../assets/images/cmp-databinding-7.png"
    alt=""
    class="img-responsive d-flex m-auto" />
  <p>
    Everything before <b>event 1</b> is called when Angular initialize, and in
    order, the events on <b>event 1</b> occurs when that new server is created,
    and events in the <b>event 2</b> occurs when the
    <b>Destroy First Element</b> button is clicked, remaining just the latest
    server created
  </p>
  <br /><br />
  <h3><b>Lifecycle Hooks and Template Access</b></h3>
  <br />
  <p>
    Depending on the time the hook runs, it can't access some properties, values
    or elements in your DOM, like the case we applied on <i>server name</i> on
    <span class="code">serve-element.component</span>:
  </p>
  <pre>
    <h5>server-element.component.html</h5>
    <p>We added <span class="code">#heading</span> local reference to the server name HTML line</p>
    <code class="code no-border">
      &lt;div class=&quot;panel panel-default&quot;&gt;
        &lt;div class=&quot;panel-heading&quot; #heading&gt;&lbrace; &lbrace; name &rbrace; &rbrace;&lt;/div&gt;
        &lt;div class=&quot;panel-body&quot;&gt;
          &lt;ng-content&gt;&lt;/ng-content&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    </code>
  </pre>
  <pre>
    <h5>server-element.component.ts</h5>
    <p>And here we tested with <span class="code">ngOnInit()</span> and <span class="code">ngAfterViewInit()</span> the exactly point where we can have access to template elements:</p>
    <code class="code no-border">
      ngOnInit() &lbrace;
        console.log('ngOnInit called');
        console.log('Text Content:' + this.header.nativeElement.textContent);
      &rbrace;

      ngAfterViewInit(): void &lbrace;
        console.log('ngAfterViewInit called');
        console.log('Text Content:' + this.header.nativeElement.textContent);
      &rbrace;
    </code>
  </pre>
  <img
    src="../assets/images/cmp-databinding-8.png"
    alt=""
    class="img-responsive d-flex m-auto" /><br /><br />
  <br /><br />
  <h3><b>Getting Access to ng-content with @ContentChild</b></h3>
  <br />
  <p>
    We used <span class="code">@ViewChild()</span> with
    <b>local reference</b> on
    <span class="code">server-element.component.ts</span> to access the template
    (server name) of this same component on
    <span class="code">server-element.component.html</span>. But now we added a
    <b>local reference</b> on a tag that is in the
    <span class="code">app.component.html</span>, between the
    <span class="code">server-element.component</span> selector
    <span class="code"
      >&lt;app-server-element&gt;&lt;/app-server-element&gt;</span
    >:
  </p>
  <pre>
    <code class="code no-border">
      &lt;app-server-element
        *ngFor=&quot;let serverElement of serverElements&quot;
        [srvElement]=&quot;serverElement&quot;
        [name]=&quot;serverElement.name&quot;
      &gt;
        &lt;p #contentParagraph&gt;
          &lt;strong *ngIf=&quot;serverElement.type === &apos;server&apos;&quot; style=&quot;color: red&quot;&gt;&lbrace; &lbrace;
            serverElement.content
          &rbrace; &rbrace;&lt;/strong&gt;
          &lt;em *ngIf=&quot;serverElement.type === &apos;blueprint&apos;&quot;&gt;&lbrace; &lbrace;
            serverElement.content
          &rbrace; &rbrace;&lt;/em&gt;
        &lt;/p&gt;
      &lt;/app-server-element&gt;
    </code>
  </pre>
  <p>
    So the intent here is access a
    <span class="code">server-element.component</span> content, the server
    paragraph this time, since it is between its selectors. For that we're going
    to use <span class="code">@ContentChild()</span> in the
    <span class="code">server-element.component.ts</span>, responsible for the
    content at the end.
  </p>
  <pre>
    <code class="code no-border">
      @ContentChild(&apos;contentParagraph&apos;, &lbrace; static: true &rbrace;) paragraph: ElementRef;
  </code>
  <p class="obs"><span class="code">@ContentChild()</span> also needs to be imported from @angular/core</p>
</pre>
  <p>
    Here we can see when <span class="code">@ContentChild()</span> make
    available the <i>server content</i> content (after
    <span class="code">ngAfterContentInit</span> is called)
  </p>
  <img
    src="../assets/images/cmp-databinding-9.png"
    alt=""
    class="img-responsive d-flex m-auto" /><br /><br />
  <br /><br />
  <h3>
    <b
      >Assignment 4: Practicing Property & Event Binding and View
      Encapsulation</b
    >
  </h3>
  <br />
  <p><b>1.</b>Create three new components: GameControl, Odd and Even</p>
  <p>
    <b>2.</b>The GameControl Component should have buttons to start and stope
    the game
  </p>
  <p>
    <b>3.</b>When starting the game, an event (holding a incrementing number)
    should get emitted each second (ref = setInterval())
  </p>
  <p><b>4.</b>The event should be listenable from outside the component</p>
  <p>
    <b>5.</b>When stopping the game, no more events should get emitted
    (clearInteval())
  </p>
  <p>
    <b>6.</b>A new Odd component should get created for every odd number
    emitted, the same should happen for the Even Component (on even numbers)
  </p>
  <p>
    <b>7.</b>Simply output Odd - NUMBER or Even - NUMBER in the two components
  </p>
  <p>
    <b>8.</b>Style the element (e.g. paragraph) holding your output text
    differently in both components
  </p>
  <div class="card">
    <div class="card-header"><b>Result View</b></div>
    <div class="card-body">
      <app-game-control
        (intervalFired)="onIntervalFired($event)"></app-game-control>
      <app-odd
        *ngFor="let oddNumber of oddNumbers"
        [number]="oddNumber"></app-odd>
      <app-even
        *ngFor="let evenNumber of evenNumbers"
        [number]="evenNumber"></app-even>
    </div>
  </div>
  <br />
  <p>
    <i>
      "You can pass values <b>from a parent to a child component</b> using
      <b>[property binding]</b> in the parent and
      <span class="code">@Input()</span> in the child <br /><br />

      You can pass values <b>from a child to a parent component</b> using
      <b>(event binding)</b> in the parent and
      <span class="code">@Output()</span> in the child. <br /><br />

      This syntax is rather intuitive: <span class="code">@Input()</span> marks
      <b>inputs</b> into the child (coming from its parent),
      <span class="code">@Output()</span> marks <b>outputs</b> from the child
      (to its parent). <br /><br />

      (A <b>direct</b> parent/child relationship of two components is
      established by the fact that the selector of the child component is placed
      somewhere in the template of the parent component.)" </i
    ><br />Jost - Technical Assistent from course <br />
    <br />
    <img
      src="../assets/images/assignment-4.png"
      class="img-repsonsive d-flex m-auto" />
  </p>
  <br /><br />
  <h3>
    <b>Adding Navigation with Event Biding (@Output) and ngIf </b>
  </h3>
  <br />
  <p>
    In the <b><i>Recipie App</i></b> project, we want to display pages only when
    they're clicked in the menu, having <i>Recipes</i> as default page
  </p>
  <br />
  <img
    class="img-responsive d-flex m-auto"
    src="../assets/images/recipie-app-initial-menu.png" />
  <br />
  <p>
    <b>1.</b> In the <span class="code">header.html</span>, we bind a
    <span class="code">(click)</span> event on the links returning an argument
    <br />
  </p>
  <pre>
    <code class="code no-border">
      &lt;li class=&quot;nav-item&quot;&gt;
        &lt;a
          class=&quot;nav-link active&quot;
          aria-current=&quot;page&quot;
          href=&quot;#&quot;
          (click)=&quot;onSelect(&apos;recipe&apos;)&quot;
          &gt;Recipes&lt;/a
        &gt;
      &lt;/li&gt;
      &lt;li class=&quot;nav-item&quot;&gt;
        &lt;a class=&quot;nav-link&quot; href=&quot;#&quot; (click)=&quot;onSelect(&apos;shopping-list&apos;)&quot;
          &gt;Shopping List&lt;/a
        &gt;
      &lt;/li&gt;
    </code>
  </pre>
  <p>
    <b>2.</b> In the <span class="code">header.component</span>, we create an
    <span class="code">@Output</span> to emit the event that will receive a
    string <span class="code">&lt;string&gt;()</span>, and the
    <b><i>onSelect( )</i></b> click function, that once triggered, pass the
    argument received in the <span class="code">header.html</span> as a string
    <span class="code">(feature)</span> and emit this same string with the
    <span class="code">@Output EventEmitter</span>
    <br />
  </p>
  <pre>
    <code class="code no-border">
      @Output() featureSelected = new EventEmitter&lt;string&gt;();

      onSelect(feature: string) &lbrace;
        this.featureSelected.emit(feature);
      &rbrace;
    </code>
  </pre>
  <p>
    <b>3.</b> In the <span class="code">app.html</span>, in the
    <span class="code">&lt;app-header&gt;&lt;/app-header&gt;</span> selector, we
    bind the <span class="code">(featureSelected)</span> event that we created
    with the <span class="code">@Output</span> in the
    <span class="code">header.component</span>, with a new function that receive
    the data being emitted in the moment we click in the link
  </p>
  <pre>
    <code class="code no-border">
      &lt;app-header (featureSelected)=&quot;onNavigate($event)&quot;&gt;&lt;/app-header&gt;
    </code>
  </pre>
  <p class="obs">
    If we click in <b>Recipe</b> link, <span class="code">($event)</span> will
    receive <span class="code">'recipe'</span>, as defined in the
    <span class="code">header.html</span>. The same with <b>Shopping List</b>
  </p>
  <p>
    <b>4.</b> In the <span class="code">app.component</span>, we defined the
    variable <span class="code">loadedFeatured</span> as
    <span class="code">'recipe'</span> to define this page as default. Then we
    create the <b><i>onNavigate( )</i></b> function that receives the same
    string <span class="code">(feature)</span>
    <i
      >(that will be 'recipe' or 'shopping-list', depending on the user
      click)</i
    >
    and assign it to the <span class="code">loadedFeature</span> variable as a
    new value
  </p>
  <pre>
    <code class="code no-border">
      loadedFeature = &apos;recipe&apos;;
      onNavigate(feature: string) &lbrace;
        this.loadedFeature = feature;
      &rbrace;
    </code>
  </pre>
  <p>
    <b>5.</b> Back to the <span class="code">app.hmtl</span>, we're going to use
    the <span class="code">*ngIf</span> to toggle between the pages, binding it
    into the
    <span class="code">&lt;app-recipes&gt;&lt;/app-recipes&gt;</span> and
    <span class="code"
      >&lt;app-shopping-list&gt;&lt;/app-shopping-list&gt;</span
    >
    selectors
  </p>
  <pre>
    <code class="code no-border">
      &lt;app-header (featureSelected)=&quot;onNavigate($event)&quot;&gt;&lt;/app-header&gt;
      &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;row&quot;&gt;
          &lt;div class=&quot;col-md-12&quot;&gt;
            &lt;app-recipes *ngIf=&quot;loadedFeature === &apos;recipe&apos;&quot;&gt;&lt;/app-recipes&gt;
            &lt;app-shopping-list *ngIf=&quot;loadedFeature !== &apos;recipe&apos;&quot;&gt;&lt;/app-shopping-list&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    </code>
  </pre>
  <p>
    <span class="code"
      >*ngIf=&quot;loadedFeature === &apos;recipe&apos;&quot;</span
    >
    allows the
    <span class="code">&lt;app-recipes&gt;&lt;/app-recipes&gt;</span> being
    displayed just when the argument received in the
    <span class="code">(featureSelected)=&quot;onNavigate($event)&quot;</span>
    is equal to <span class="code">'recipe'</span>; And the same for the
    <span class="code">'shopping-list'</span>
  </p>
  <br /><br />
  <h3>
    <b>Passing Recipe Data with Property Binding</b>
  </h3>
  <br />
  <p>
    To pass data dynamically to another component, let's use the
    <span class="code">@Input</span> in the <i>'child'</i> component
    <span class="code">recipe-item</span> and property binding in the
    <span class="code">&lt;app-recipe-item&gt;&lt;/app-recipe-item&gt;</span>
    selector inside <i>'parent'</i> component
    <span class="code">recipe-list</span>
  </p>
  <p>
    <b>1.</b> We create the piece of code responsible for the recipe-item layout
    in the <span class="code">recipe-item.html</span>
  </p>
  <pre>
    <code class="code no-border">
      &lt;a href=&quot;#&quot; class=&quot;list-group-item clearfix&quot;&gt;
        &lt;div class=&quot;pull-left&quot;&gt;
          &lt;h4 class=&quot;list-group-item-heading&quot;&gt;&lbrace; &lbrace; recipe.name &rbrace; &rbrace;&lt;/h4&gt;
          &lt;p class=&quot;list-group-item-text&quot;&gt;&lbrace; &lbrace; recipe.description &rbrace;&rbrace;&lt;/p&gt;
        &lt;/div&gt;
        &lt;span class=&quot;pull-right&quot;&gt;
          &lt;img
            [src]=&quot;recipe.imagePath&quot;
            alt=&quot;&lbrace; &lbrace; recipe.name &rbrace; &rbrace;&quot;
            class=&quot;img-responsive&quot;
            style=&quot;max-height: 50px&quot;
          /&gt;
        &lt;/span&gt;
      &lt;/a&gt;
    </code>
  </pre>
  <p>
    In the <span class="code">recipe-item.component</span> we add the
    <span class="code">@Input</span> responsible for <b><i>allow</i></b> the
    <span class="code">recipe</span> property being accessible from outside,
    specifically, by the 'parent' component
    <span class="code">recipe-list</span>
  </p>
  <pre>
    <code class="code no-border">
      @Input() recipe: Recipe;
    </code>
  </pre>
  <p>
    <b>'Recipe'</b> here is the model with the properties that we're accessing
    in the string interpolation in the
    <span class="code">recipe-item.html</span>: &lbrace; &lbrace; recipe.name
    &rbrace; &rbrace; and &lbrace; &lbrace; recipe.description &rbrace; &rbrace;
    and can be fulfilled in the
    <span class="code">recipe-list.component</span>
    <i>(thanks to the <span class="code">@Input</span>)</i>
  </p>
  <br />
  <p>
    <b>2.</b> In the <span class="code">recipe-list.html</span>, we add the
    <span class="code">ngFor</span> at the
    <span class="code">&lt;app-recipe-item&gt;&lt;/app-recipe-item&gt;</span>
    selector to loop over and exhibit all recipes in the array defined in
    <span class="code">recipe-list.component</span>; Also, we bind the property
    <span class="code">[recipe]</span> defined in the
    <span class="code">recipe-item.component</span>, assign to it, one by one,
    all the elements of the recipes array: <span class="code">"recipeEl"</span>
  </p>
  <br />
  <pre>
    <b>*ngFor</b>
    <code class="code no-border">
      &lt;app-recipe-item
      *ngFor=&quot;let recipeEl of recipes&quot;
      [recipe]=&quot;recipeEl&quot;
      &gt;&lt;/app-recipe-item&gt;
    </code>
    <b>Recipes array </b>
    <code class="code no-border">
      recipes: Recipe[] = [
        new Recipe(
          &apos;A Test Recipe&apos;,
          &apos;This is simply a test&apos;,
          &apos;https://www.supergoldenbakes.com/wordpress/wp-content/uploads/2019/10/Hungarian_Goulash_s.jpg&apos;
        ), new Recipe()...
      ];
    </code>
  </pre>
  <img
    class="img-responsive d-flex m-auto"
    src="../assets/images/recipe-item.png" />
  <br /><br />
  <h3>
    <b>Passing Data with Event and Property Binding (Combined)</b>
  </h3>
  <br />
  <p>
    Now, we want to <mark>open</mark> the <b>recipe detail</b> on the right side
    <mark>when</mark> the <b>recipe item</b> is <mark>clicked</mark> in the
    <b>recipe list</b>, on left side. (Remembering: recipe list and recipe
    detail selectors are inside the recipe component - it'll impact in the event
    listening steps)
  </p>
  <p>
    <b>1.</b> Since que clickable item is the
    <span class="code">recipe-item.html</span>, we're going to bind a
    <span class="code">(click)</span> event to know when it's triggered
  </p>
  <pre>
    <code class="code no-border">
      &lt;a href=&quot;#&quot; class=&quot;list-group-item clearfix&quot; (click)=&quot;onSelected()&quot;&gt;
        &lt;div class=&quot;pull-left&quot;&gt;
          &lt;h4 class=&quot;list-group-item-heading&quot;&gt;&lbrace; &lbrace; recipe.name &rbrace; &rbrace;&lt;/h4&gt;
          &lt;p class=&quot;list-group-item-text&quot;&gt;&lbrace; &lbrace; recipe.description &rbrace;&rbrace;&lt;/p&gt;
        &lt;/div&gt;
        &lt;span class=&quot;pull-right&quot;&gt;
          &lt;img
            [src]=&quot;recipe.imagePath&quot;
            alt=&quot;&lbrace; &lbrace; recipe.name &rbrace; &rbrace;&quot;
            class=&quot;img-responsive&quot;
            style=&quot;max-height: 50px&quot;
          /&gt;
        &lt;/span&gt;
      &lt;/a&gt;
    </code>
  </pre>
  <p>
    On <span class="code">(click)=&quot;onSelected()&quot;</span>, we don't need
    to pass any arguments, because just the <i>'click'</i> need to be
    <i>'heard'</i>
  </p>
  <p>
    <b>2.</b> In the <span class="code">recipe-item.component</span>, we add the
    <span class="code">onSelected()</span> function and a event emitter
    <span class="code">recipeSelected</span> with
    <span class="code">@Output</span>, so we can know when the recipe item is
    selected.
  </p>
  <pre>
    <code class="code no-border">
      @Output() recipeSelected = new EventEmitter&lt;void&gt;();
        <p class="obs"><b>&lt;void&gt;</b> means that this event won&apos;t pass any information</p>
      
        onSelected() &lbrace;
          this.recipeSelected.emit();
        &rbrace;
          <p class="obs"> we don&apos;t need to pass any arguments because is the &apos;recipe-list&apos; that will be actually hearing this event emission</p>
    </code>
  </pre>
  <p>
    Once again, in the <span class="code">recipeSelected</span> event emitter,
    we don't need to pass any arguments because it's just to make the
    <i>(click)</i> event to be heard, that's why we used
    <span class="code">&lt;void&gt;()</span>; As it is with
    <span class="code">onSelected()</span>
  </p>
  <p>
    <b>3.</b> In the <span class="code">recipe-list.html</span>, we bind to the
    <span class="code">&lt;app-recipe-item&gt;&lt;/app-recipe-item&gt;</span>
    selector, the event <span class="code">recipeSelected</span>, created in the
    <span class="code">recipe-item.component</span>, so the click inside the
    <span class="code">recipe-item.component</span> can be heard in the
    <span class="code">recipe-list</span>.
  </p>
  <pre>
    <code class="code no-border">
      &lt;app-recipe-item
      *ngFor=&quot;let recipeEl of recipes&quot;
      [recipe]=&quot;recipeEl&quot;
      (recipeSelected)=&quot;onRecipeSelected(recipeEl)&quot;
      &gt;&lt;/app-recipe-item&gt;
    </code>
  </pre>
  <p>
    Once <span class="code">(recipeSelected)</span> happens, the
    <span class="code">onRecipeSelected(recipeEl)</span> is triggered, passing
    the respective recipe element selected as argument <i>(recipeEl)</i>
  </p>
  <p>
    <b>Important point:</b> The
    <span class="code">@Output / EventEmitter</span> works in levels, so a
    parent can't <i>hear</i> an event from a child of a child, we need to
    <i>construct</i> this path. So we need to make the event in the inner child,
    <b>level (3)</b>, in this case, the
    <span class="code">recipe-item</span> being heard by the outter child,
    <b>level (2)</b>, in this case, the <span class="code">recipe-list</span>,
    and finally reaching the parent, <b>level (1)</b>, in this case,
    <span class="code">recipe.component</span>. The
    <span class="code">recipe-detail</span> component works side-to-side, as
    'sibling', of the <span class="code">recipe-list</span>
  </p>
  <p>
    In the <span class="code">recipe-list.component</span>, we need to emit a
    new event, so it can be heard by the parent component
    <span class="code">recipe</span>
  </p>
  <pre>
    <code class="code no-border">
      @Output() recipeWasSelected = new EventEmitter&lt;Recipe&gt;();
      <span class="obs">Here we're using the model <b>Recipe</b> as a type</span>
      onRecipeSelected(recipe: Recipe) &lbrace;
        this.recipeWasSelected.emit(recipe);
      &rbrace;
      <span class="obs">Again, we're using the model <b>Recipe</b> as a type and emitting the current recipe element in the loop</span>
    </code>
  </pre>
  <p>
    <b>4.</b> In the <span class="code">recipe.html</span>, we can bind the
    <span class="code">(recipeWasSelected)</span> event to the
    <span class="code">&lt;app-recipe-list&gt;&lt;/app-recipe-list&gt;</span>
    selector, and assing to it a property that will stored this recipe selected,
    using the '=' attribute sign to receive the data <i>$event</i>
  </p>
  <pre>
    <code class="code no-border">
      selectedRecipe: Recipe;
      <span class="obs">the property need to receive <span class="code">Recipe</span> model as type</span>
    </code>
  </pre>
  <p>
    The details must be displayed just when the <b>recipe is selected</b>, so
    still in the <span class="code">recipe.html</span>, we're going to configure
    the
    <span class="code"
      >&lt;app-recipe-detail&gt;&lt;/app-recipe-detail&gt;</span
    >
    to work this way with <span class="code">*ngIf</span>:
  </p>
  <pre>
    <code class="code no-border">
      &lt;app-recipe-detail
      *ngIf=&quot;selectedRecipe; else infoText&quot;
      [recipe]=&quot;selectedRecipe&quot;
      &gt;&lt;/app-recipe-detail&gt;
      &lt;ng-template #infoText&gt;
        &lt;p&gt;Please select a Recipe!&lt;/p&gt;
      &lt;/ng-template&gt;
    </code>
  </pre>
  <p>
    <span class="code">*ngIf=&quot;selectedRecipe; else infoText&quot;</span>
    display the recipe details just if its the type of
    <span class="code">Recipe</span>, as we defined in the
    <span class="code">recipe.component</span>; Otherwise (else), it will
    display the dummy text inside the
    <span class="code">&lt;ng-template&gt;&lt;/ng-template&gt;</span>
  </p>
  <p>
    <b>5.</b>Finally, to be able to see the same data of
    <span class="code">recipe-item</span> displayed in the
    <span class="code">recipe-detail</span>, we binded a property
    <span class="code">[recipe]=&quot;selectedRecipe&quot;</span> to its
    selector in the <span class="code">recipe.html</span>. This property, as we
    already seen, was defined with <span class="code">@Input</span> in the
    <span class="code">recipe-detail.component</span> and receives the
    <span class="code">selectedRecipe</span>, which represents the current
    recipe element:
  </p>
  <pre>
    <code class="code no-border">
      @Input() recipe: Recipe;
    </code>
  </pre>
  <img
    class="img-responsive d-flex m-auto"
    src="../assets/images/recipe-detail-default.png" />
  <img
    class="img-responsive d-flex m-auto"
    src="../assets/images/recipe-detail-data.png" />
  <br /><br />
  <h3>
    <b>Allowing the User to Add Ingredients to the Shopping List</b>
  </h3>
  <br />
  <p>
    In the 'Shopping List' page, we already have a CRUD (form) for the recipes
    ingredients and we want to let it more <mark>functional</mark>, configuring
    the code to be able to <mark>add</mark>, <mark>delete</mark> and
    <mark>clear</mark> the form. For that, we're going to use
    <span class="code">@ViewChild</span> and
    <span class="code">#local_reference</span><br />
    <span class="obs"
      >(We're going to config the <b>Add</b> function, for now)</span
    >
  </p>
  <img
    src="../assets/images/recipie-app-toggle-menu.png"
    class="img-responsive d-flex m-auto" />
  <hr />
  <br />
  <p>
    <b>1.</b> In <span class="code">shopping-edit.html</span>, we add a
    <span class="code">#nameIpunt</span> local reference in the
    <span class="code">&lt;input id=&quot;name&quot;&gt;</span> and
    <span class="code">#amountInput</span> in the
    <span class="code">&lt;input id=&quot;amount&quot;&gt;</span>
  </p>
  <pre>
    <code class="code no-border">
      &lt;div class=&quot;col-sm-5 form-group&quot;&gt;
        &lt;label for=&quot;name&quot;&gt;Name&lt;/label&gt;
        &lt;input type=&quot;text&quot; id=&quot;name&quot; class=&quot;form-control&quot; #nameInput /&gt;
      &lt;/div&gt;
      &lt;div class=&quot;col-sm-2 form-group&quot;&gt;
        &lt;label for=&quot;amount&quot;&gt;Amount&lt;/label&gt;
        &lt;input type=&quot;text&quot; id=&quot;Amount&quot; class=&quot;form-control&quot; #amountInput /&gt;
      &lt;/div&gt;
    </code>
  </pre>
  <p>
    In the <b>Add</b> button, we're going to bind a <b>click</b> event to use as
    event listener later
  </p>
  <pre>
    <code class="code no-border">
      &lt;button class=&quot;btn btn-success&quot; type=&quot;submit&quot; (click)=&quot;onAddItem()&quot;&gt;
        Add
      &lt;/button&gt;
    </code>
  </pre>
  <p>
    <b>2.</b> In the <span class="code">shopping-edit.component</span>, we're
    going to use <span class="code">@ViewChild</span> approach to get the
    <span class="code">#local_references</span> values, indicating inside the
    <b>( )</b>, the <span class="code">#local_references</span> names
  </p>
  <pre>
    <code class="code no-border">
      @ViewChild(&apos;nameInput&apos;, &lbrace; static: false &rbrace;) nameInputRef: ElementRef;
      @ViewChild(&apos;amountInput&apos;, &lbrace; static: false &rbrace;) amountInputRef: ElementRef;
    </code>
  </pre>
  <p>
    With these two inputs added, now we can emit a new event with
    <span class="code">@Output</span> where we pass these data to the
    <b>parent</b> component <span class="code">shopping-list</span> as the
    object model <span class="code">Ingredient</span>
  </p>
  <pre>
    <code class="code no-border">
      @ViewChild(&apos;nameInput&apos;, &lbrace; static: false &rbrace;) nameInputRef: ElementRef;
      @ViewChild(&apos;amountInput&apos;, &lbrace; static: false &rbrace;) amountInputRef: ElementRef;
      @Output() ingredientAdded = new EventEmitter&lt;Ingredient&gt;();
    </code>
  </pre>
  <p>
    To finish this component configuration, we're going to create the event
    listener <span class="code">onAddItem()</span>
  </p>
  <pre>
    <code class="code no-border">
      onAddItem() &lbrace;
        const ingredientName = this.nameInputRef.nativeElement.value;
        const ingredientAmount = this.amountInputRef.nativeElement.value;
        const newIngredient = new Ingredient(ingredientName, ingredientAmount);
        this.ingredientAdded.emit(newIngredient);
      &rbrace;
    </code>
  </pre>
  <p>
    Once this function is triggered, we store the inputs values into the
    <b><i>ingredientName</i></b> and <b><i>ingredientAmount</i></b
    >, using the <span class="code">@ViewChild</span> properties
    <b><i>nameInputRef</i></b> and <b><i>amountInputRef</i></b> (which those
    were already referencing to the inputs
    <span class="code">#local_references</span>), and create another variable
    <b><i>ingredientsAdded</i></b
    >to store the sum of these ingredients as a new object (using
    <i>'Ingredient' model</i> type)
  </p>
  <p>
    <b>Important point:</b><br />In the line
    <span class="code"
      >const newIngredient = new Ingredient(ingredientName,
      ingredientAmount);</span
    >, the order is a criteria, and it should be 'name' first and 'amount'
    after, otherwise, they will be inverted
  </p>
  <p>
    <b>3.</b> In the <span class="code">shopping-list.html</span>, which is the
    parent component of <span class="code">shopping-edit</span>, we can now
    <b><i>'listen'</i></b> to the
    <span class="code">(ingredientAdded)</span> event (that we created back in
    the <span class="code">shopping-edit</span>) and get data from the
    <span class="code">shopping-edit</span> event
  </p>
  <pre>
    <span><b>shopping-list.html</b></span>
    <code class="code no-border">
      &lt;app-shopping-edit
      (ingredientAdded)=&quot;onIngredientAdded($event)&quot;
    &gt;&lt;/app-shopping-edit&gt;
    </code>
    <span><b>shopping-list.ts</b></span>
    <code class="code no-border">
      onIngredientAdded(ingredient: Ingredient) &lbrace;
        this.ingredients.push(ingredient);
      &rbrace;
    </code>
  </pre>
</div>
